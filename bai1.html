<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bài 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="css/test.css">
</head>
<body class="flex flex-col items-center justify-between min-h-screen bg-gray-100">
    <header >
        <h1 class="textheader">An Khùng</h1>
        <button id="exit-button" class="btnExit">Thoát</button>
        <a href="index.html" class="btnHome">
            <i class="fa-solid fa-arrow-left" style="color: rgb(0, 0, 0); font-size: 20px; font-weight: bold; margin-left: 8px;"></i>Trang Chủ.
        </a>
    </header>
    <!-- Container chính (Chia làm 2 cột trên màn hình lớn) -->
    <div class="container mx-auto px-4 my-8 grid grid-cols-1 md:grid-cols-10 gap-8 items-start">
        <!-- KHUNG BÊN TRÁI: NỘI DUNG CÂU HỎI (7/10 cột) -->
        <div id="quiz-container" class="bg-white p-8 rounded-2xl shadow-xl w-full md:col-span-7">
            <!-- Màn hình bắt đầu bài kiểm tra -->
            <div id="start-screen" class="text-center">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">Bài 1</h1>
                <p class="text-gray-600 mb-6">Chào mừng bạn đến với bài kiểm tra! Hãy nhấn "Bắt đầu" để bắt đầu.</p>
                <button id="start-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Bắt đầu</button>
            </div>
            <!-- Nội dung Quiz: Hiển thị câu hỏi và đáp án -->
            <div id="quiz-content" class="hidden">
                <!-- Bộ đếm câu hỏi (VD: 1/10) -->
                <p id="question-counter" class="text-lg font-semibold text-gray-700 mb-2"></p>
                <!-- Tiêu đề/Nội dung câu hỏi -->
                <h2 id="question-text" class="text-xl text-gray-1500 mb-2"></h2><br>
                <!-- Hình minh họa câu hỏi (nếu có) -->
                <div id="question-image-container" class="mb-4 hidden">
                    <img id="question-image" src="" alt="Minh họa câu hỏi" class="mx-auto rounded-xl shadow-lg max-h-64 object-contain">
                </div>
                <!-- Thông báo cho câu hỏi Multi-Select -->
                <p id="multiselect-info" class="text-sm text-red-500 font-medium mb-4 hidden"><i>Chọn 2 đáp án đúng!</i></p>
                <!-- 1. Container cho Single/Multi-Select (Chọn đáp án) -->
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- Các nút đáp án được tạo bằng JavaScript -->
                </div>
                <!-- 2. Container cho Drag & Drop (Kéo thả) -->
                <div id="dragdrop-container" class="hidden">
                    <p class="text-sm text-blue-500 font-medium mb-4">Kéo thả theo ý đúng</p>
                    <!-- Vùng kéo (Source): Chứa các thẻ chưa được thả -->
                    <div id="draggable-items-source" class="source-drop-zone drop-zone flex flex-wrap gap-3 p-4 bg-gray-50 border rounded-xl mb-6 shadow-inner">
                        <p class="text-gray-500 text-sm italic w-full source-placeholder">Kéo các thẻ ở đây... </p>
                    </div>
                    <!-- Vùng thả (Targets): Chứa các Category -->
                    <div id="drop-targets-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    </div>
                </div>
                <!-- 3. Container cho Fill-in-the-Blank (Điền từ) -->
                <div id="fill-in-the-blank-container" class="space-y-4 hidden mt-6">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <input 
                            type="text" 
                            id="fill-in-the-blank-input" 
                            placeholder="Nhập đáp án của bạn..." 
                            class="flex-grow p-3 border border-gray-300 rounded-lg transition duration-150"
                        >
                        <button 
                            id="check-fill-in-the-blank-button"
                            class="check-button-enabled text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:bg-gray-400"
                            onclick="checkFillInTheBlank()"
                        >
                            Kiểm tra đáp án
                        </button>
                    </div>
                </div>
                <!-- Thanh điều hướng dưới cùng -->
                <div class="flex justify-end items-center mt-6 border-t pt-4 space-x-4">
                    <button 
                        id="check-answer-button" 
                        class="hidden text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105"
                    >
                        Kiểm tra
                    </button>
                    <button 
                        id="next-button" 
                        class="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-full shadow-md transition-all duration-300 transform hover:scale-105"
                    >
                        Tiếp
                    </button>
                </div>
            </div>
            <!-- Màn hình kết quả cuối bài thi -->
            <div id="results-screen" class="hidden text-center">
                <h2 class="text-3xl font-bold text-green-600 mb-4">Hoàn thành bài kiểm tra!</h2>
                <!-- HIỂN THỊ ĐIỂM SỐ ĐÃ TỐI ƯU HÓA -->
                <div class="bg-blue-50 p-6 rounded-2xl shadow-xl inline-block mb-6">
                    <p class="text-xl font-semibold text-gray-700">Điểm số của bạn:</p>
                    <!-- Thẻ hiển thị điểm số cuối cùng -->
                    <p id="final-score" class="text-6xl font-extrabold text-blue-700 mt-2">0 / 0</p>
                </div>
                <p id="result-message" class="text-gray-700 mb-6">Bạn có thể xem lại các câu trả lời của mình trên giao diện.</p>
                <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Làm lại</button>
            </div>
        </div>
        <!-- KHUNG BÊN PHẢI: SIDEBAR (3/10 cột) -->
        <div id="sidebar" class="bg-white p-6 rounded-2xl shadow-xl w-full hidden md:block md:col-span-3 sticky top-8">
            <div class="mb-6 text-center">
                <p class="text-xl font-semibold text-gray-700 mb-2">Thời gian làm bài:</p>
                <!-- Đồng hồ đếm ngược/đếm thời gian -->
                <div id="timer" class="text-4xl font-bold text-red-500">00:00</div>
            </div>
            <div>
                <p class="text-lg font-semibold text-gray-700 mb-4">Danh sách câu hỏi:</p>
                <!-- Danh sách các nút câu hỏi để nhảy qua lại -->
                <div id="question-list-container" class="grid grid-cols-4 gap-2">
                    <!-- Các nút câu hỏi được tạo bằng JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="w-full bg-gray-800 text-white text-center py-4 px-6 mt-auto">
        <p class="text-sm">&copy; Website luyện tập!!!</p>
    </footer>
    <script>
        let questions = [
        // ===== CÂU 1 =====
            {
                question: "Vận hành phần mềm theo góc nhìn của người dùng cuối là gì?",
                options: [
                    "A. Quá trình sửa lỗi trong phần mềm",
                    "B. Quá trình cải tiến hệ thống",
                    "C. Cách người dùng tương tác với hệ thống để đạt mục tiêu",
                    "D. Tìm lỗi logic"
                ],
                answer: "C. Cách người dùng tương tác với hệ thống để đạt mục tiêu",
                type: "single_select"
            },
        // ===== CÂU 2 =====
            {
                question: "Mục tiêu của bảo trì phòng ngừa là gì?",
                options: [
                    "A. Thêm chức năng mới",
                    "B. Ngăn ngừa lỗi có thể phát sinh",
                    "C. Kiểm tra tính bảo mật",
                    "D. Tối ưu hóa giao diện"
                ],
                answer: "B. Ngăn ngừa lỗi có thể phát sinh",
                type: "single_select"
            },
        // ===== CÂU 3 =====
            {
                question: "Một phần mềm được đánh giá là 'dễ bảo trì' khi nào?",
                options: [
                    "A. Có giao diện đẹp, được lập trình bởi nhiều người",
                    "B. Có cấu trúc rõ ràng, dễ hiểu, dễ thay đổi",
                    "C. Có mã nguồn",
                    "D. Có nhiều tính năng"
                ],
                answer: "B. Có cấu trúc rõ ràng, dễ hiểu, dễ thay đổi",
                type: "single_select"
            },
        // ===== CÂU 4 =====
            {
                question: "Loại bảo trì nào liên quan đến việc thêm tính năng mới dựa trên phản hồi người dùng?",
                options: [
                    "A. Bảo trì hiệu chỉnh",
                    "B. Bảo trì thích nghi",
                    "C. Bảo trì phòng ngừa",
                    "D. Bảo trì tiến hóa"
                ],
                answer: "D. Bảo trì tiến hóa",
                type: "single_select"
            },
        // ===== CÂU 5 =====
            {
                question: "Lập trình viên nên làm gì trước khi thay đổi mã nguồn trong quá trình bảo trì?",
                options: [
                    "A. Sửa ngay mã nguồn để tiết kiệm thời gian",
                    "B. Đổi tên project",
                    "C. Hiểu rõ nguyên nhân và tác động của thay đổi",
                    "D. Xóa mã cũ"
                ],
                answer: "C. Hiểu rõ nguyên nhân và tác động của thay đổi",
                type: "single_select"
            },
        // ===== CÂU 6 =====

            {
                question: "DevOps kết hợp chặt chẽ giữa ____?",
                options: [
                    "A. Kinh doanh và marketing",
                    "B. Phân tích và thiết kế",
                    "C. Phát triển và vận hành",
                    "D. Kiểm thử và bảo trì"
                ],
                answer: "C. Phát triển và vận hành",
                type: "single_select"
            },
        // ===== CÂU 7 =====

            {
                question: "Bảo trì thích nghi (Adaptive Maintenance) là gì?",
                options: [
                    "A. Tối ưu thuật toán để đáp ứng thay đổi từ đối tác",
                    "B. Loại bỏ chức năng cũ, bổ sung chức năng mới",
                    "C. Cập nhật phần mềm sao cho hoạt động ổn định trên môi trường mới",
                    "D. Cải thiện giao diện người dùng"
                ],
                answer: "C. Cập nhật phần mềm sao cho hoạt động ổn định trên môi trường mới",
                type: "single_select"
            },
        // ===== CÂU 8 =====
            {
                question: "Trong quy trình bảo trì phần mềm, bước đầu tiên thường là gì?",
                options: [
                    "A. Triển khai phần mềm mới",
                    "B. Phân tích yêu cầu thay đổi",
                    "C. Viết mã mới",
                    "D. Kiểm thử hệ thống"
                ],
                answer: "B. Phân tích yêu cầu thay đổi",
                type: "single_select"
            },
        // ===== CÂU 9 =====
            {
                question: "Các công cụ thường dùng trong DevOps là những công cụ nào?<br>(Chọn 3 đáp án đúng)",
                options: [
                    "A. Git/Github, Gitlab, Bitbucket",
                    "B. Microsoft excel, Microsoft word",
                    "C. Maven/Gradle, Nexus, SonarQube",
                    "D. Jenkins, Docker, K8s"
                ],
                answer: ["A. Git/Github, Gitlab, Bitbucket", "C. Maven/Gradle, Nexus, SonarQube", "D. Jenkins, Docker, K8s"],
                type: "multi_select"
            },
        // ===== CÂU 10 =====
            {
                question: "Quy trình đảm bảo phần mềm hoạt động ổn định sau triển khai gọi là gì?",
                options: ["A. Kiểm thử phần mềm", "B. Vận hành phần mềm", "C. Phát triển phần mềm", "D. Thiết kế hệ thống"],
                answer: "B. Vận hành phần mềm",
                type: "single_select"
            },
        // ===== CÂU 11 =====

            {
                question: "Yếu tố nào quan trọng nhất giúp phần mềm dễ bảo trì?",
                options: [
                    "A. Dùng ít dòng mã",
                    "B. Nhiều file cấu hình",
                    "C. Có cấu trúc rõ ràng và được chú thích tốt",
                    "D. Dùng nhiều thư viện ngoài"
                ],
                answer: "C. Có cấu trúc rõ ràng và được chú thích tốt",
                type: "single_select"
            },
        // ===== CÂU 12 =====

            {
                question: "Đặc điểm khác biệt quan trọng của DevOps so với quy trình truyền thống là gì?",
                options: [
                    "A. Triển khai thủ công",
                    "B. Không cần kiểm thử nghiêm ngặt",
                    "C. Tự động hóa quy trình với công cụ hiện đại",
                    "D. Không cần quản lý lỗi"
                ],
                answer: "C. Tự động hóa quy trình với công cụ hiện đại",
                type: "single_select"
            },
        // ===== CÂU 13 =====

            {
                question: "Bảo trì hiệu chỉnh (Corrective Maintenance) nhằm mục đích gì?",
                options: [
                    "A. Hiệu chỉnh phần mềm để nâng cao hiệu suất trước khi triển khai",
                    "B. Hiệu chỉnh lại kế hoạch dự án",
                    "C. Sửa lỗi sau khi phần mềm được triển khai đến người dùng cuối",
                    "D. Cập nhật lại bản thiết kế phần mềm"
                ],
                answer: "C. Sửa lỗi sau khi phần mềm được triển khai đến người dùng cuối",
                type: "single_select"
            },
        // ===== CÂU 14.1 =====

        {
            question: "Bảo trì phần mềm được tiến hành trước khi triển khai đến môi trường người dùng?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 14.2 =====

        {
            question: "Một trong các lợi ích quan trọng của bảo trì phần mềm là đảm bảo phần mềm hoạt động ổn định, lâu dài và nâng cao trải nghiệm người dùng?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 14.3 =====

        {
            question: "Việc đảm bảo phần mềm hoạt động đúng và ổn định sau khi đưa vào sử dụng là trách nhiệm của khách hàng và người dùng, không thuộc trách nhiệm của nhóm vận hành?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 14.4 =====

        {
            question: "Bảo trì phần mềm là quá trình duy trì và cải tiến phần mềm sau khi triển khai?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 15.1 =====

        {
            question: "Theo dõi phiên bản mới của thư viện phụ thuộc dự án và cập nhật định kỳ để ngăn ngừa lỗ hổng bảo mật, tránh các sự cố có thể xảy ra là ví dụ của bảo trì phòng ngừa (Preventive maintenance)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 15.2 =====

        {
            question: "Nâng cấp tính năng tìm kiếm để tối ưu về mặt hiệu năng là một ví dụ về bảo trì tiến hóa (Evolutionary maintenance)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 15.3 =====

        {
            question: "Sửa lỗi chức năng tìm kiếm do trả về kết quả sai khi người dùng sử dụng là ví dụ về bảo trì thích nghi (Adaptive maintenance)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 15.4 =====

        {
            question: "Di chuyển ứng dụng sang hạ tầng mới (như hạ tầng đám mây) là ví dụ về bảo trì sửa lỗi (Corrective maintenance)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 16.1 =====

        {
            question: "Các quy trình phần mềm linh hoạt không loại bỏ được vấn đề tam giác thép?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 16.2 =====

        {
            question: "Vấn đề tam giác thép được hiểu là: sự cố định về lập yêu cầu sẽ dẫn đến lịch biểu cố định, ngân quỹ và các công nghệ cũng được cố định theo lịch biểu. Các thành viên tham gia triển khai dự án phải bám sát kế hoạch, liên tục bị thúc ép deadline, chỉ cần thay đổi yêu cầu khách hàng hoặc không hoàn thành công việc đúng tiến độ, dự án có thể dẫn đến thất bại.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 16.3 =====

        {
            question: "Mô hình quy trình thác nước (Waterfall model) loại bỏ hoàn toàn được vấn đề tam giác thép (iron triangle)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 16.4 =====

        {
            question: "Các quy trình phần mềm lặp không loại bỏ được vấn đề tam giác thép?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 17.1 =====

        {
            question: "RUP, Spiral là các mô hình quy trình phần mềm thuộc loại quy trình dự đoán (predictive processes)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 17.2 =====

        {
            question: "RUP, Spiral là các mô hình quy trình phần mềm thuộc loại quy trình lặp (iterative processes)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 17.3 =====

        {
            question: "Scrum và Kanban thuộc loại quy trình phần mềm linh hoạt (Adaptive Processes)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 17.4 =====

        {
            question: "Scrum và Kanban thuộc loại quy trình phần mềm dự đoán (predictive processes)?",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 18.1 =====

        {
            question: "Agile dựa trên nguyên tắc kinh tế: “The later we deliver a feature the sooner our customers will pay us for it”.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 18.2 =====

        {
            question: "DevOps có đầy đủ các lợi thế của các mô hình quy trình Agile.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 18.3 =====

        {
            question: "Agile dựa trên nguyên tắc kinh tế: “The sooner we deliver a feature, the sooner our customers will pay us for it”.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 18.4 =====

        {
            question: "Với Agile, ROI tăng, do giá trị đặc trưng của sản phẩm tăng theo thời gian.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 19.1 =====

        {
            question: "Một trong các lợi ích quan trọng của bảo trì phần mềm là đảm bảo phần mềm hoạt động ổn định, lâu dài, và nâng cao trải nghiệm người dùng.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 19.2 =====

        {
            question: "Việc đảm bảo phần mềm hoạt động đúng và ổn định sau khi đưa vào sử dụng là trách nhiệm của khách hàng, và người dùng, không thuộc trách nhiệm của nhóm vận hành.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        // ===== CÂU 19.3 =====

        {
            question: "Bảo trì phần mềm là quá trình duy trì và cải tiến phần mềm sau khi triển khai.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
        // ===== CÂU 19.3 =====

        {
            question: "Bảo trì phần mềm được tiến hành trước khi phần mềm được triển khai đến môi trường người dùng.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        {
                question: "Kéo đúng loại cặp Loại bảo trì với Mục đích chính",
                type: "drag_drop",
                categories: ["Adaptive", "Perfective", "Corrective", "Preventive"],
                items: [
                    { id: "item1", text: "1.Thích nghi môi trường mới", correctCategory: "Adaptive" },
                    { id: "item2", text: "2.Cải thiện tính năng", correctCategory: "Perfective" },
                    { id: "item3", text: "3.sửa lỗi", correctCategory: "Corrective" },
                    { id: "item4", text: "4.ngăn ngừa lỗi tiềm ẩn", correctCategory: "Preventive" },
                ]
            },
            {
                question: "Kéo mô tả vào đúng giai đoạn tương ứng của DevOps",
                type: "drag_drop",
                categories: ["Monitoring", "Deploying","Building","Coding", "Testing"],
                items: [
                    { id: "item1", text: "A. Theo dõi hệ thống vận hành", correctCategory: "Monitoring" },
                    { id: "item2", text: "B. Triển khai lên môi trường vận hành.", correctCategory: "Deploying" },
                    { id: "item3", text: "C. Biên dịch mã nguồn", correctCategory: "Building" },
                    { id: "item4", text: "D. Viết mã", correctCategory: "Coding" },
                    { id: "item5", text: "E. Kiểm thử", correctCategory: "Testing" },
                ]
            },
            {
                question: "Kéo đúng mô tả vào giai đoạn tương ứng trong quy trình DevOps ?",
                type: "drag_drop",
                categories: ["Test", "Release","Plan","Build"],
                items: [
                    { id: "item1", text: "A. Kiểm thử tự động", correctCategory: "Test" },
                    { id: "item2", text: "B. Phát hành sản phẩm", correctCategory: "Release" },
                    { id: "item3", text: "C. Xác định yêu cầu và lộ trình", correctCategory: "Plan" },
                    { id: "item4", text: "D. Biên dịch và đóng gói ứng dụng", correctCategory: "Build" },
                ]
            },            
            {
                question: "Kéo công cụ vào đúng nhóm chức năng",
                type: "drag_drop",
                categories: ["Git", "Jenkins","Docker","SonarQube"],
                items: [
                    { id: "item1", text: "Quản lý mã nguồn", correctCategory: "Git" },
                    { id: "item2", text: "CI/CD pipeline", correctCategory: "Jenkins" },
                    { id: "item3", text: "Container hóa", correctCategory: "Docker" },
                    { id: "item4", text: "Phân tích mã nguồn tĩnh", correctCategory: "SonarQube" },
                ]
            },
            {
                question: "So sánh DevOps với Waterfall, DevOps với Agile, hãy kéo các đặc điểm tương ứng?",
                type: "drag_drop",
                categories: ["DevOps", "Waterfall","Agile"],
                items: [
                    { id: "item1", text: "A. Triển khai liên tục, phản hồi nhanh", correctCategory: "DevOps" },
                    { id: "item2", text: "B. Tuần tự từng giai đoạn, chậm đổi mới", correctCategory: "Waterfall" },
                    { id: "item3", text: "C. Tập trung vào phát triển phần mềm linh hoạt", correctCategory: "Agile" },
                    ]
            },
            {
                question: "Kéo công cụ vào đúng nhóm chức năng",
                type: "drag_drop",
                categories: ["Spiral", "RUP","DevOps","Scrum"],
                items: [
                    { id: "item1", text: "Bổ sung thêm phân tích rủi ro", correctCategory: "Spiral" },
                    { id: "item2", text: "Lặp hai chiều và hướng đối tượng", correctCategory: "RUP" },
                    { id: "item3", text: "Tự động hóa & triển khai liên tục", correctCategory: "DevOps" },
                    { id: "item4", text: "Product backlog được kiểm soát bởi Product Owner", correctCategory: "Scrum" },
                ]
            },
            // CÂU HỎI ĐIỀN TỪ (FILL-IN-THE-BLANK)
            {
                question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau đây:<br>Bước đầu tiên trong quy trình DevOps là (1)___, bước cuối cùng trong quy trình DevOps là (2)___. Công cụ hỗ trợ cho bước đầu tiên là (3)___, công cụ hỗ trợ cho bước cuối cùng là (4)___. DevOps giúp cải thiện thời gian phát hành phần mềm bằng cách tự động hóa quy trình build và deploy.<br>Biết các thông tin có thể điền bao gồm: lập kế hoạch, giám sát hệ thống vận hành, jira, elk.",
                answer: "lập kế hoạch, giám sát hệ thống vận hành, jira, elk",
                type: "fill_in_the_blank"
            },
            {
                question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau đây:<br>DevOps là sự kết hợp giữa ___(1) và ___(2), nhằm tối ưu quy trình phát triển phần mềm.Trong đó, nhóm ___(3)___ chịu trách nhiệm phát triển , trong khi  nhóm ___(4)___ chịu trách nhiệm về cơ sở hạ tầng, triển khai ứng dụng, giám sát ứng dụng vận hành và đảm bảo ứng dụng hoạt động ổn định, hiệu quả trên môi trường vận hành .<br>Biết các thông tin có thể điền bao gồm : dev, ops, phát triển, vận hành , lập trình, kiểm thử .",
                answer: "dev, ops, phát triển, vận hành ",
                type: "fill_in_the_blank"
            },
            {
                question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau đây: <br>Trong quy trình Devops, giai đoạn ____(1)____ bao gồm việc lập kế hoạch phát triển các chức năng và kế hoạch phát hành cho lần lặp chu trình tiếp theo. DevOps giúp rút ngắn ___(2)___ để phần mềm được phát hành nhanh hơn và kết nối 2 vai trò chính là phát triển và ___(3)___ trong chu trình<br>Biết các thông tin có thể điền bao gồm : lập kế hoạch , chu kì phát hành, vận hành , viết code",
                answer: "lập kế hoạch , chu kì phát hành, vận hành",
                type: "fill_in_the_blank"
            },
        ];

        let currentQuestionIndex = 0; // Chỉ số câu hỏi hiện tại
        let elapsedTime = 0; // Thời gian làm bài (giây)
        let timerInterval; // Biến lưu trữ Interval của đồng hồ
        let answeredQuestions = new Array(questions.length).fill(null);
        let correctnessStatus = new Array(questions.length).fill(null);
        // Lấy các phần tử DOM cần thiết
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const quizContent = document.getElementById('quiz-content');
        const questionCounter = document.getElementById('question-counter');
        const multiselectInfo = document.getElementById('multiselect-info');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const dragdropContainer = document.getElementById('dragdrop-container');
        const draggableItemsSource = document.getElementById('draggable-items-source');
        const dropTargetsContainer = document.getElementById('drop-targets-container');
        const fillInTheBlankContainer = document.getElementById('fill-in-the-blank-container');
        const fillInTheBlankInput = document.getElementById('fill-in-the-blank-input');
        const checkFillInTheBlankButton = document.getElementById('check-fill-in-the-blank-button');
        const checkAnswerButton = document.getElementById('check-answer-button'); // Nút kiểm tra chung (Multi-select, Drag & Drop)
        const nextButton = document.getElementById('next-button');
        const resultsScreen = document.getElementById('results-screen');
        const restartButton = document.getElementById('restart-button');
        // SỬA LỖI VÀ TÍNH ĐIỂM: Thêm các dòng này để khai báo biến DOM
        const resultMessage = document.getElementById('result-message'); 
        const exitButton = document.getElementById('exit-button'); 
        const finalScore = document.getElementById('final-score'); // Thẻ hiển thị điểm số
        
        const sidebar = document.getElementById('sidebar');
        const timerDisplay = document.getElementById('timer');
        const questionListContainer = document.getElementById('question-list-container');
        function normalizeString(str) {
            let normalized = str.toLowerCase().trim();
            normalized = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
            return normalized.replace(/\s+/g, '');
        }
        fillInTheBlankInput.onkeypress = (event) => {
            if (event.key === 'Enter') checkFillInTheBlank();
        };
        function drag(event) {
            event.dataTransfer.setData("text/plain", event.target.id);
            event.target.classList.add('opacity-50');
        }
        function dragEnd(event) {
            event.target.classList.remove('opacity-50');
        }
        function allowDrop(event) {
            event.preventDefault(); // Cho phép thả
            const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        function dragLeave(event) {
             const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        function drop(event, categoryName) {
            event.preventDefault();
            let targetZone = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            // Nếu đã kiểm tra (có feedback), không cho phép tương tác
            if (!targetZone || correctnessStatus[currentQuestionIndex] !== null) return; 
            targetZone.classList.remove('drag-over');
            const itemId = event.dataTransfer.getData("text/plain");
            const draggedElement = document.getElementById(itemId);
            if (draggedElement) {
                const oldParent = draggedElement.parentElement;
                if (oldParent) {
                    oldParent.removeChild(draggedElement);
                }
                targetZone.appendChild(draggedElement);
                let currentAnswer = answeredQuestions[currentQuestionIndex] || {};
                const itemText = draggedElement.textContent.trim(); 

                const isDroppedBackToSource = targetZone.id === 'draggable-items-source';

                if (isDroppedBackToSource) {
                    delete currentAnswer[itemText]; 
                } else { 
                    currentAnswer[itemText] = categoryName;
                }
                answeredQuestions[currentQuestionIndex] = Object.keys(currentAnswer).length > 0 ? currentAnswer : null;
                updateButtonStates();
            }
        }
        function checkCorrectness(questionIndex, selectedAnswers) {
            const currentQuestion = questions[questionIndex];
            if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = selectedAnswers || answeredQuestions[questionIndex];
                if (!droppedAnswers) return false;
                if (Object.keys(droppedAnswers).length !== currentQuestion.items.length) {
                    return false;
                }
                return currentQuestion.items.every(item => {
                    const droppedCategory = droppedAnswers[item.text];
                    return droppedCategory === item.correctCategory;
                });
            } else if (currentQuestion.type === "fill_in_the_blank") {
                 const userAnswer = selectedAnswers || answeredQuestions[questionIndex];
                 if (!userAnswer) return false;
                 const normalizedUserAnswer = normalizeString(userAnswer);
                 const normalizedCorrectAnswer = normalizeString(currentQuestion.answer);

                 return normalizedUserAnswer === normalizedCorrectAnswer;
            } else {
                const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                if (!Array.isArray(selectedAnswers)) {
                    selectedAnswers = selectedAnswers !== null ? [selectedAnswers] : [];
                }
                if (selectedAnswers.length !== correctAnswers.length) {
                    return false;
                }
                selectedAnswers.sort();
                correctAnswers.sort();
                return JSON.stringify(selectedAnswers) === JSON.stringify(correctAnswers);
            }
        }
        function showQuestion() {
            const currentQuestion = questions[currentQuestionIndex];
            questionCounter.textContent = `Câu hỏi: ${currentQuestionIndex + 1} / ${questions.length}`;
            questionText.innerHTML = currentQuestion.question;
            // ======= HIỂN THỊ HÌNH ẢNH MINH HỌA NẾU CÓ =======
            const imageContainer = document.getElementById("question-image-container");
            const imageElement = document.getElementById("question-image");
            if (currentQuestion.image) {
                imageElement.src = currentQuestion.image;
                imageContainer.classList.remove("hidden");
            } else {
                imageContainer.classList.add("hidden");
            }
            optionsContainer.classList.add('hidden');
            multiselectInfo.classList.add('hidden');
            dragdropContainer.classList.add('hidden');
            fillInTheBlankContainer.classList.add('hidden'); 
            checkAnswerButton.classList.add('hidden'); 
            if (currentQuestion.type === "drag_drop") {
                renderDragDropUI(currentQuestion);
                dragdropContainer.classList.remove('hidden');
            } else if (currentQuestion.type === "fill_in_the_blank") {
                renderFillInTheBlankUI(currentQuestion);
                fillInTheBlankContainer.classList.remove('hidden');
            } else {
                renderSelectUI(currentQuestion);
                optionsContainer.classList.remove('hidden');
            }
            nextButton.textContent = currentQuestionIndex >= questions.length - 1 ? "Hoàn thành bài thi" : "Câu tiếp theo";
            updateButtonStates();
            updateSidebarHighlight();
        }
        function renderSelectUI(currentQuestion) {
            const isMulti = currentQuestion.type === "multi_select";
            multiselectInfo.classList.toggle('hidden', !isMulti);
            checkAnswerButton.classList.toggle('hidden', !isMulti); // Hiển thị nút kiểm tra chỉ cho Multi-Select
            optionsContainer.innerHTML = '';
            const savedAnswer = answeredQuestions[currentQuestionIndex];
            const savedAnswersArray = Array.isArray(savedAnswer) ? savedAnswer : (savedAnswer !== null ? [savedAnswer] : []);
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option;
                let classes = [
                    "answer-button", "w-full", "py-3", "px-4", "rounded-xl", "text-center", 
                    "bg-gray-100", "border-2", "border-gray-300", 
                    "transition-all", "duration-200",
                    "font-medium", "text-gray-800", "shadow-sm"
                ];
                button.classList.add(...classes);
                if (isChecked) {
                    button.disabled = true;
                    button.classList.add("cursor-not-allowed");
                    const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                    const isCorrectOption = correctAnswers.includes(option);
                    const isUserSelected = savedAnswersArray.includes(option);
                    if (isCorrectOption) {
                        button.classList.add("bg-green-500", "text-white", "border-green-600");
                        button.classList.remove("bg-gray-100", "border-gray-300");
                    }
                    if (isUserSelected && !isCorrectOption) {
                        button.classList.add("bg-red-500", "text-white", "border-red-600");
                        button.classList.remove("bg-green-500", "border-green-600", "bg-gray-100", "border-gray-300");
                    }
                } else {
                    button.classList.add("hover:bg-blue-100", "hover:border-blue-500");
                    if (isMulti) {
                        button.addEventListener('click', (e) => {
                            toggleSelection(e.currentTarget);
                            updateButtonStates(); 
                        });
                    } else {
                        button.addEventListener('click', (e) => singleSelectCheck(option, e.currentTarget));
                    }
                    if (savedAnswersArray.includes(option)) {
                        button.classList.add('selected-option');
                    }
                }
                optionsContainer.appendChild(button);
            });
        }
        function renderFillInTheBlankUI(currentQuestion) {
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const savedAnswer = answeredQuestions[currentQuestionIndex] || "";
            fillInTheBlankInput.value = savedAnswer;
            fillInTheBlankInput.disabled = isChecked;
            fillInTheBlankInput.classList.remove('correct', 'incorrect');
            checkFillInTheBlankButton.classList.toggle('hidden', isChecked);
            if (isChecked) {
                const isCorrect = correctnessStatus[currentQuestionIndex];
                fillInTheBlankInput.classList.add(isCorrect ? 'correct' : 'incorrect');
                if (!isCorrect) {
                     fillInTheBlankInput.placeholder = `Đáp án đúng: ${currentQuestion.answer}`;
                }
            } else {
                fillInTheBlankInput.placeholder = "Nhập đáp án của bạn...";
            }
            updateButtonStates(); 
        }
        function checkFillInTheBlank() {
            const userAnswer = fillInTheBlankInput.value.trim();
            if (userAnswer === "") {
                showMessage("Vui lòng nhập đáp án vào ô trống.", "yellow");
                return;
            }// 1. Lưu đáp án
            answeredQuestions[currentQuestionIndex] = userAnswer;
            checkAndApplyFeedback(currentQuestionIndex); 
            fillInTheBlankInput.disabled = true;
            checkFillInTheBlankButton.classList.add('hidden');
            updateButtonStates(); 
        }// --- Render Logic cho Drag & Drop ---
        function renderDragDropUI(currentQuestion) {
            draggableItemsSource.innerHTML = '';
            dropTargetsContainer.innerHTML = '';
            const savedDrops = answeredQuestions[currentQuestionIndex] || {};
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const itemsDataMap = new Map(currentQuestion.items.map(item => [item.text, item]));
            checkAnswerButton.classList.remove('hidden');
            const sourcePlaceholder = document.createElement('p');
            sourcePlaceholder.classList.add('text-gray-500', 'text-sm', 'italic', 'w-full', 'source-placeholder');
            draggableItemsSource.ondragover = allowDrop;
            draggableItemsSource.ondragleave = dragLeave;
            if (!isChecked) {
                draggableItemsSource.ondrop = (e) => drop(e, null); 
                sourcePlaceholder.textContent = 'Kéo các thẻ ở đây... (Kéo thẻ từ ô đáp án về đây để "kéo ra")'; 
                sourcePlaceholder.classList.toggle('hidden', currentQuestion.items.length !== Object.keys(savedDrops).length);
            } else {
                draggableItemsSource.ondrop = null; // Vô hiệu hóa kéo/thả
                sourcePlaceholder.textContent = 'Đã hoàn thành.';
                sourcePlaceholder.classList.add('hidden'); 
            }
            draggableItemsSource.appendChild(sourcePlaceholder);
            const dropZones = {};
            currentQuestion.categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.classList.add('bg-gray-50', 'p-4', 'rounded-xl', 'shadow-md', 'flex', 'flex-col');
                const title = document.createElement('h3');
                title.textContent = category;
                title.classList.add('text-lg', 'font-bold', 'text-blue-700', 'mb-3', 'border-b', 'pb-2');
                categoryDiv.appendChild(title);
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone', 'flex', 'flex-wrap', 'gap-2', 'p-3', 'rounded-lg', 'flex-grow');
                dropZone.setAttribute('data-category', category);
                if (!isChecked) {
                    dropZone.ondragover = allowDrop;
                    dropZone.ondragleave = dragLeave;
                    dropZone.ondrop = (e) => drop(e, category); 
                } else {
                    dropZone.ondrop = null; 
                    dropZone.style.cursor = 'default';
                    const correctItemsForCategory = currentQuestion.items.filter(item => item.correctCategory === category);
                    const droppedItems = Object.entries(savedDrops)
                        .filter(([itemText, cat]) => cat === category)
                        .map(([itemText]) => itemText);
                    const correctlyPlacedCount = droppedItems.filter(text => itemsDataMap.get(text).correctCategory === category).length;
                    const incorrectlyPlacedCount = droppedItems.length - correctlyPlacedCount;
                    const missingCorrectCount = correctItemsForCategory.length - correctlyPlacedCount;
                    if (incorrectlyPlacedCount > 0 || missingCorrectCount > 0) {
                        dropZone.classList.add('incorrect-drop-zone');
                    } else if (correctlyPlacedCount > 0 && incorrectlyPlacedCount === 0 && missingCorrectCount === 0) {
                        dropZone.classList.add('correct-drop-zone');
                    }
                }
                dropTargetsContainer.appendChild(categoryDiv).appendChild(dropZone);
                dropZones[category] = dropZone;
            });
            currentQuestion.items.forEach(item => {
                const itemEl = createDraggableItem(item, isChecked);
                const droppedCategory = savedDrops[item.text];
                if (droppedCategory) {
                    const targetZone = dropZones[droppedCategory];
                    if (targetZone) {
                        targetZone.appendChild(itemEl);
                    }
                    if (isChecked) {
                        const isCorrect = droppedCategory === item.correctCategory;
                        itemEl.classList.remove('bg-white', 'border-gray-300');
                        itemEl.classList.add('text-gray-900', 'shadow-md', 'ring-2');
                        if (isCorrect) {
                            itemEl.classList.add('bg-green-200', 'ring-green-500');
                        } else {
                            itemEl.classList.add('bg-red-200', 'ring-red-500');
                            const correctHint = document.createElement('span');
                            correctHint.textContent = `(Đúng: ${item.correctCategory})`;
                            correctHint.classList.add('text-xs', 'text-red-700', 'mt-1', 'block', 'font-normal');
                            itemEl.appendChild(correctHint);
                        }
                    }
                } else {// Item chưa được thả -> Đặt vào vùng Source
                    draggableItemsSource.appendChild(itemEl);
                }
            });// Ẩn placeholder Source nếu không còn item nào
            const placeholder = draggableItemsSource.querySelector('.source-placeholder');
            if (placeholder) placeholder.classList.toggle('hidden', currentQuestion.items.length === Object.keys(savedDrops).length);
        }// Hàm tạo element cho thẻ kéo
        function createDraggableItem(item, isChecked) {
            const itemEl = document.createElement('div');
            itemEl.id = item.id;
            itemEl.textContent = item.text;
            itemEl.classList.add(
                'draggable-item', 'p-3', 'rounded-lg', 'shadow-sm', 'font-medium', 'text-sm', 'text-gray-800'
            );
            if (!isChecked) {
                itemEl.setAttribute('draggable', 'true');
                itemEl.ondragstart = drag;
                itemEl.ondragend = dragEnd;
            } else {
                itemEl.setAttribute('draggable', 'false');
                itemEl.style.cursor = 'default';
            }
            return itemEl;
        }// --- Logic Xử lý Đáp án (Select) ---
        function toggleSelection(button) {
            button.classList.toggle('selected-option');
        }
        function singleSelectCheck(selectedOption, button) {
            answeredQuestions[currentQuestionIndex] = selectedOption;
            checkAndApplyFeedback(currentQuestionIndex);
            renderSelectUI(questions[currentQuestionIndex]);
            updateButtonStates();
        }// Xử lý nút CHECK ANSWER (cho Multi-Select và Drag & Drop)
        checkAnswerButton.addEventListener('click', () => {
            const currentQuestion = questions[currentQuestionIndex];
            if (currentQuestion.type === "multi_select") {
                const allOptionButtons = optionsContainer.querySelectorAll('button');
                const selectedOptions = Array.from(allOptionButtons)
                    .filter(btn => btn.classList.contains('selected-option'))
                    .map(btn => btn.textContent);
                if (selectedOptions.length === 0) {
                    showMessage("Vui lòng chọn ít nhất một đáp án trước khi kiểm tra.", "yellow");
                    return;
                }// Lưu đáp án và kiểm tra
                answeredQuestions[currentQuestionIndex] = selectedOptions;
                checkAndApplyFeedback(currentQuestionIndex);
                renderSelectUI(questions[currentQuestionIndex]);
            } else if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = answeredQuestions[currentQuestionIndex];
                const isAllDropped = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                if (!isAllDropped) {
                    showMessage("Vui lòng kéo thả tất cả các thẻ vào vị trí trước khi kiểm tra.", "yellow");
                    return;
                }
                checkAndApplyFeedback(currentQuestionIndex);
                renderDragDropUI(questions[currentQuestionIndex]); // Render lại để hiển thị feedback
            }
            updateButtonStates();
        });
        // Hàm kiểm tra và áp dụng phản hồi
        function checkAndApplyFeedback(questionIndex) {
            const savedAnswer = answeredQuestions[questionIndex];
            const isCorrect = checkCorrectness(questionIndex, savedAnswer);
            const currentQuestionType = questions[questionIndex].type;
            if (isCorrect) {
                showMessage("🎉 Chúc mừng, đáp án chính xác!", "green");
            } else {
                if (currentQuestionType === "fill_in_the_blank") {
                     showMessage(`Sai rồi. Đáp án đúng là: ${questions[questionIndex].answer}.`, "red");
                } else if (currentQuestionType === "drag_drop") {
                     showMessage(`Sai rồi. Đáp án kéo thả chưa hoàn toàn chính xác. Vui lòng xem phản hồi màu sắc!`, "red");
                } else {
                     showMessage("Sai rồi. Vui lòng xem lại kết quả (Màu xanh lá là đúng, đỏ là sai)!", "red");
                }
            }
            correctnessStatus[questionIndex] = isCorrect;
            // Xử lý feedback cho Fill-in-the-Blank (cần gọi lại renderFillInTheBlankUI để update placeholder)
            if (currentQuestionType === "fill_in_the_blank") {
                renderFillInTheBlankUI(questions[questionIndex]);
            }
            updateSidebarHighlight(); // Cập nhật màu sắc trên sidebar
            return isCorrect;
        }
        function updateButtonStates() {
            const currentQuestion = questions[currentQuestionIndex];
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            nextButton.disabled = !isChecked;
            nextButton.classList.toggle('bg-gray-200', !isChecked);
            nextButton.classList.toggle('text-gray-800', !isChecked);
            nextButton.classList.toggle('enabled-next', isChecked);
            if (currentQuestion.type === "multi_select" || currentQuestion.type === "drag_drop") {
                checkAnswerButton.classList.toggle('hidden', isChecked);
                if (!isChecked) {
                    let isAnswered = false;
                    if (currentQuestion.type === "drag_drop") {
                        const droppedAnswers = answeredQuestions[currentQuestionIndex];
                        isAnswered = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                    } else if (currentQuestion.type === "multi_select") {
                        const currentSelections = optionsContainer.querySelectorAll('.selected-option').length;
                        isAnswered = currentSelections > 0;
                    }
                    checkAnswerButton.disabled = !isAnswered;
                    checkAnswerButton.classList.toggle('check-button-enabled', isAnswered);
                    checkAnswerButton.classList.toggle('check-button-disabled', !isAnswered);
                }
            }// 3. Logic cho nút CHECK FILL-IN-THE-BLANK
            if (currentQuestion.type === "fill_in_the_blank") {
                if (!isChecked) {
                    const isAnswered = fillInTheBlankInput.value.trim() !== "";
                    checkFillInTheBlankButton.disabled = !isAnswered;
                    checkFillInTheBlankButton.classList.toggle('check-button-enabled', isAnswered);
                    checkFillInTheBlankButton.classList.toggle('check-button-disabled', !isAnswered);
                    fillInTheBlankInput.oninput = updateButtonStates; 
                }
            }
        }
        nextButton.addEventListener('click', nextQuestion);
        function nextQuestion() {
            if (correctnessStatus[currentQuestionIndex] === null) {
                const currentType = questions[currentQuestionIndex].type;
                if (currentType === "multi_select" || currentType === "drag_drop" || currentType === "fill_in_the-blank") {
                    showMessage("Vui lòng nhấn nút 'Kiểm tra đáp án' trước khi chuyển câu.", "yellow");
                    return;
                }
            }// Chuyển sang câu tiếp theo (hoặc hoàn thành bài thi)
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }
        function jumpToQuestion(index) {
            currentQuestionIndex = index;
            showQuestion();
        }
        function goToStartScreen() {
            clearInterval(timerInterval);
            elapsedTime = 0; 
            timerDisplay.textContent = "00:00"; // Đặt lại đồng hồ hiển thị
            quizContent.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            sidebar.classList.add('hidden');
            startScreen.classList.remove('hidden');
        }
        function showResults() {
            clearInterval(timerInterval);
            quizContent.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            
            const totalCorrect = correctnessStatus.filter(status => status === true).length;
            const totalQuestions = questions.length;
            // TỐI ƯU HÓA TÍNH ĐIỂM: Cập nhật thẻ hiển thị điểm số
            finalScore.textContent = `${totalCorrect} / ${totalQuestions}`;
            if (totalCorrect === totalQuestions) {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Xin chúc mừng! Bạn đạt kết quả tuyệt đối.`;
            } else {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Hãy xem lại các câu trả lời của mình trên giao diện nhé.`;
            }
            sidebar.classList.add('hidden');
        }
        function restartQuiz() {
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            resultsScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden'); 
            startTimer();
            createQuestionList(); 
            showQuestion();
        }
        function startTimer() {
            clearInterval(timerInterval); 
            timerInterval = setInterval(() => {
                elapsedTime++;
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        function createQuestionList() {
            questionListContainer.innerHTML = '';
            questions.forEach((q, index) => {
                const button = document.createElement('button');
                button.textContent = index + 1;
                button.classList.add(
                    "w-8", "h-8", "rounded-full", "font-medium", "text-sm",
                    "bg-gray-200", "text-gray-800", "hover:bg-blue-200",
                    "transition-colors", "duration-200"
                );
                button.setAttribute('data-index', index);
                button.addEventListener('click', () => {
                    jumpToQuestion(index);
                });
                questionListContainer.appendChild(button);
            });
        }
        function updateSidebarHighlight() {
            const allQuestionButtons = questionListContainer.querySelectorAll('button');
            allQuestionButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'bg-green-500', 'bg-red-500', 'bg-yellow-400');
                const index = parseInt(btn.getAttribute('data-index'));
                if (index === currentQuestionIndex) {
                    btn.classList.add('bg-blue-600', 'text-white');
                } else if (correctnessStatus[index] === true) {
                    btn.classList.add('bg-green-500', 'text-white');
                } else if (correctnessStatus[index] === false) {
                    btn.classList.add('bg-red-500', 'text-white');
                } else if (answeredQuestions[index] !== null) {
                    btn.classList.add('bg-yellow-400', 'text-white');
                }
            });
        }
        function showMessage(text, color) {
            const existingMessage = quizContent.querySelector('.temp-message');
            if (existingMessage) existingMessage.remove();
            const colorClasses = {
                "yellow": "bg-yellow-100 border-yellow-400 text-yellow-700",
                "red": "bg-red-100 border-red-400 text-red-700",
                "green": "bg-green-100 border-green-400 text-green-700"
            };
            const messageBox = document.createElement('div');
            messageBox.textContent = text;
            const colorClassString = colorClasses[color] || colorClasses['yellow'];
            messageBox.classList.add(
                ...colorClassString.split(' '), 
                "border", "px-4", "py-3", "rounded", "relative", "mb-4", "temp-message"
            );
            quizContent.insertBefore(messageBox, questionCounter.nextElementSibling);
            setTimeout(() => messageBox.remove(), 3000); 
        }// --- Hàm XÁO TRỘN MẢNG (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            let shuffled = array.slice(); // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }// --- Khởi tạo sự kiện ---
        startButton.addEventListener('click', () => {
            // Đảm bảo reset trạng thái trước khi bắt đầu
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            // questions = shuffleArray(questions); // Xáo trộn câu hỏi
            startScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden');
            createQuestionList();
            startTimer();
            showQuestion();
        });
        restartButton.addEventListener('click', restartQuiz);
        exitButton.addEventListener('click', () => {
            showMessage("Đã thoát khỏi bài kiểm tra. Dữ liệu làm bài hiện tại sẽ không được lưu. Đang quay về màn hình bắt đầu...", "red");
            setTimeout(goToStartScreen, 1000);
        });
    </script>
</body>
</html>