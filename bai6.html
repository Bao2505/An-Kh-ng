<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bài 6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="css/test.css">
</head>
<body class="flex flex-col items-center justify-between min-h-screen bg-gray-100">
    <header >
        <h1 class="textheader">An Khùng</h1>
        <button id="exit-button" class="btnExit">Thoát</button>
        <a href="index.html" class="btnHome">
            <i class="fa-solid fa-arrow-left" style="color: rgb(0, 0, 0); font-size: 20px; font-weight: bold; margin-left: 8px;"></i>Trang Chủ.
        </a>
    </header>
    <!-- Container chính (Chia làm 2 cột trên màn hình lớn) -->
    <div class="container mx-auto px-4 my-8 grid grid-cols-1 md:grid-cols-10 gap-8 items-start">
        <!-- KHUNG BÊN TRÁI: NỘI DUNG CÂU HỎI (7/10 cột) -->
        <div id="quiz-container" class="bg-white p-8 rounded-2xl shadow-xl w-full md:col-span-7">
            <!-- Màn hình bắt đầu bài kiểm tra -->
            <div id="start-screen" class="text-center">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">Bài 6</h1>
                <p class="text-gray-600 mb-6">Chào mừng bạn đến với bài kiểm tra! Hãy nhấn "Bắt đầu" để bắt đầu.</p>
                <button id="start-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Bắt đầu</button>
            </div>
            <!-- Nội dung Quiz: Hiển thị câu hỏi và đáp án -->
            <div id="quiz-content" class="hidden">
                <!-- Bộ đếm câu hỏi (VD: 1/10) -->
                <p id="question-counter" class="text-lg font-semibold text-gray-700 mb-2"></p>
                <!-- Tiêu đề/Nội dung câu hỏi -->
                <h2 id="question-text" class="text-xl text-gray-1500 mb-2"></h2><br>
                <!-- Hình minh họa câu hỏi (nếu có) -->
                <div id="question-image-container" class="mb-4 hidden">
                    <img id="question-image" src="" alt="Minh họa câu hỏi" class="mx-auto rounded-xl shadow-lg max-h-64 object-contain">
                </div>
                <!-- Thông báo cho câu hỏi Multi-Select -->
                <p id="multiselect-info" class="text-sm text-red-500 font-medium mb-4 hidden"><i>2 đáp án đúng!</i></p>
                <!-- 1. Container cho Single/Multi-Select (Chọn đáp án) -->
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- Các nút đáp án được tạo bằng JavaScript -->
                </div>
                <!-- 2. Container cho Drag & Drop (Kéo thả) -->
                <div id="dragdrop-container" class="hidden">
                    <p class="text-sm text-blue-500 font-medium mb-4">Kéo thả theo ý đúng</p>
                    <!-- Vùng kéo (Source): Chứa các thẻ chưa được thả -->
                    <div id="draggable-items-source" class="source-drop-zone drop-zone flex flex-wrap gap-3 p-4 bg-gray-50 border rounded-xl mb-6 shadow-inner">
                        <p class="text-gray-500 text-sm italic w-full source-placeholder">Kéo các thẻ ở đây... </p>
                    </div>
                    <!-- Vùng thả (Targets): Chứa các Category -->
                    <div id="drop-targets-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    </div>
                </div>
                <!-- 3. Container cho Fill-in-the-Blank (Điền từ) -->
                <div id="fill-in-the-blank-container" class="space-y-4 hidden mt-6">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <input 
                            type="text" 
                            id="fill-in-the-blank-input" 
                            placeholder="Nhập đáp án của bạn..." 
                            class="flex-grow p-3 border border-gray-300 rounded-lg transition duration-150"
                        >
                        <button 
                            id="check-fill-in-the-blank-button"
                            class="check-button-enabled text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:bg-gray-400"
                            onclick="checkFillInTheBlank()"
                        >
                            Kiểm tra đáp án
                        </button>
                    </div>
                </div>
                <!-- Thanh điều hướng dưới cùng -->
                <div class="flex justify-end items-center mt-6 border-t pt-4 space-x-4">
                    <button 
                        id="check-answer-button" 
                        class="hidden text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105"
                    >
                        Kiểm tra
                    </button>
                    <button 
                        id="next-button" 
                        class="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-full shadow-md transition-all duration-300 transform hover:scale-105"
                    >
                        Tiếp
                    </button>
                </div>
            </div>
            <!-- Màn hình kết quả cuối bài thi -->
            <div id="results-screen" class="hidden text-center">
                <h2 class="text-3xl font-bold text-green-600 mb-4">Hoàn thành bài kiểm tra!</h2>
                <!-- HIỂN THỊ ĐIỂM SỐ ĐÃ TỐI ƯU HÓA -->
                <div class="bg-blue-50 p-6 rounded-2xl shadow-xl inline-block mb-6">
                    <p class="text-xl font-semibold text-gray-700">Điểm số của bạn:</p>
                    <!-- Thẻ hiển thị điểm số cuối cùng -->
                    <p id="final-score" class="text-6xl font-extrabold text-blue-700 mt-2">0 / 0</p>
                </div>
                <p id="result-message" class="text-gray-700 mb-6">Bạn có thể xem lại các câu trả lời của mình trên giao diện.</p>
                <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Làm lại</button>
            </div>
        </div>
        <!-- KHUNG BÊN PHẢI: SIDEBAR (3/10 cột) -->
        <div id="sidebar" class="bg-white p-6 rounded-2xl shadow-xl w-full hidden md:block md:col-span-3 sticky top-8">
            <div class="mb-6 text-center">
                <p class="text-xl font-semibold text-gray-700 mb-2">Thời gian làm bài:</p>
                <!-- Đồng hồ đếm ngược/đếm thời gian -->
                <div id="timer" class="text-4xl font-bold text-red-500">00:00</div>
            </div>
            <div>
                <p class="text-lg font-semibold text-gray-700 mb-4">Danh sách câu hỏi:</p>
                <!-- Danh sách các nút câu hỏi để nhảy qua lại -->
                <div id="question-list-container" class="grid grid-cols-4 gap-2">
                    <!-- Các nút câu hỏi được tạo bằng JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="w-full bg-gray-800 text-white text-center py-4 px-6 mt-auto">
        <p class="text-sm">&copy; Website luyện tập!!!</p>
    </footer>
    <script>
        let questions = [
            // Câu 1
            {
                question: "Phân tích mã nguồn tĩnh (Static Code Analysis) là gì?",
                options: [
                    "A. Kiểm tra mã bằng cách chạy ứng dụng",
                    "B. Xem log hệ thống",
                    "C. Phân tích mã mà không cần thực thi chương trình",
                    "D. Thực hiện kiểm thử người dùng"
                ],
                answer: "C. Phân tích mã mà không cần thực thi chương trình",
                type: "single_select"
            },
            // Câu 2
            {
                question: "Điểm giống nhau giữa kiểm thử và phân tích mã nguồn tĩnh là gì?",
                options: [
                    "A. Cả hai đều dựa vào phản hồi người dùng",
                    "B. Cả hai đều phát hiện lỗi, vấn đề tiềm ẩn trong phần mềm",
                    "C. Cả hai chỉ dùng trong giai đoạn bảo trì",
                    "D. Cả hai đều yêu cầu chạy ứng dụng"
                ],
                answer: "B. Cả hai đều phát hiện lỗi, vấn đề tiềm ẩn trong phần mềm",
                type: "single_select"
            },
            // Câu 3
            {
                question: "Kiểm thử đơn vị (Unit Test) thuộc loại nào?",
                options: [
                    "A. Phân tích tĩnh",
                    "B. Kiểm thử động",
                    "C. Sửa lỗi thuật toán trong mã nguồn",
                    "D. Fix các lỗ hổng bảo mật"
                ],
                answer: "B. Kiểm thử động",
                type: "single_select"
            },
            // Câu 4
            {
                question: "Khi nào nên thực hiện phân tích mã nguồn tĩnh trong vòng đời phần mềm?",
                options: [
                    "A. Sau khi triển khai",
                    "B. Khi người dùng phản ánh lỗi",
                    "C. Trong giai đoạn phát triển trước khi build",
                    "D. Trong giai đoạn marketing"
                ],
                answer: "C. Trong giai đoạn phát triển trước khi build",
                type: "single_select"
            },
            // Câu 5
            {
                question: "Kiểm thử tích hợp thường được sử dụng để kiểm tra điều gì?",
                options: [
                    "A. Giao diện người dùng",
                    "B. Tính hợp lệ của mã nguồn",
                    "C. Sự tương tác giữa các module",
                    "D. Quá trình cài đặt phần mềm"
                ],
                answer: "C. Sự tương tác giữa các module",
                type: "single_select"
            },
            // Câu 6
            {
                question: "Đâu là công cụ thường dùng để kiểm thử bảo mật?",
                options: [
                    "A. Postman",
                    "B. Selenium",
                    "C. Jmeter",
                    "D. ZAP"
                ],
                answer: "D. ZAP",
                type: "single_select"
            },
            // Câu 7
            {
                question: "Đâu là công cụ thường dùng để kiểm thử API?",
                options: [
                    "A. SonarQube",
                    "B. SonarLint",
                    "C. Postman",
                    "D. Nunit"
                ],
                answer: "C. Postman",
                type: "single_select"
            },
            // Câu 8.1
            {
                question: "Postman chỉ hỗ trợ kiểm thử API sử dụng phương thức GET.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 8.2

            {
                question: "Trong Postman, người dùng có thể viết script kiểm thử bằng JavaScript để kiểm thử.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 8.3

            {
                question: "Postman không hỗ trợ tạo biến môi trường global, và local.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 8.4

            {
                question: "Trong phần “Tests” hoặc 'script' của Postman, bạn có thể viết test kiểm tra status code và body content.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 9.1

            {
                question: "ZAP có thể hoạt động như một proxy để chặn và chỉnh sửa request/response.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 9.2

            {
                question: "ZAP không hỗ trợ kiểm thử tự động, chỉ làm thủ công.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 9.3

            {
                question: "ZAP có thể phát hiện các lỗ hổng phổ biến như XSS, SQL Injection.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 9.4

            {
                question: "ZAP yêu cầu phải có tài khoản trả phí mới được sử dụng tính năng kiểm thử cơ bản.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 10.1

            {
                question: "Postman có thể chạy mô phỏng nhiều request đồng thời để kiểm thử tải (load test).",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 10.2

            {
                question: "Postman chỉ có thể chạy tuần tự các request, không sinh tải đồng thời.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 10.3

            {
                question: "Postman Collection có thể kết hợp với Newman để chạy batch kiểm thử.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 10.4

            {
                question: "Có thể áp dụng Postman để kiểm thử API và kiểm thử hiệu năng.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 11
            {
                question: "Mục tiêu chính của phân tích mã nguồn tĩnh là gì?",
                options: [
                    "A. Tối ưu hóa tốc độ CPU",
                    "B. Đánh giá hiệu suất máy chủ",
                    "C. Phát hiện lỗi logic, vi phạm quy ước lập trình trước khi chạy",
                    "D. Kiểm thử sự tương thích với trình duyệt"
                ],
                answer: "C. Phát hiện lỗi logic, vi phạm quy ước lập trình trước khi chạy",
                type: "single_select"
            },
            // Câu 12

            {
                question: "Công cụ nào dùng để phân tích mã nguồn tĩnh? (chọn 2 đáp án)",
                options: [
                    "A. SonarQube",
                    "B. Junit",
                    "C. Nunit",
                    "D. SpotBug"
                ],
                answer: ["A. SonarQube", "D. SpotBug"],
                type: "multi_select"
            },
            // Câu 13

            {
                question: "Đâu là công cụ có thể dùng để kiểm thử hiệu năng?",
                options: [
                    "A. Postman",
                    "B. AUnit",
                    "C. KUnit",
                    "D. PerformanceTest"
                ],
                answer: "A. Postman",
                type: "single_select"
            },
            // Câu 14.1

            {
                question: "ZAP hoàn toàn miễn phí theo chuẩn OWASP.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 14.2

            {
                question: "Postman không phù hợp để kiểm thử hiệu năng quy mô lớn.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 14.3

            {
                question: "JMeter phù hợp để kiểm thử hiệu năng với quy mô lớn.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 14.4

            {
                question: "Có thể đo thời gian phản hồi (response time) của API ngay trong Postman.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 15.1

            {
                question: "SonarQube cần chạy ứng dụng để phân tích mã nguồn.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 15.2

            {
                question: "SonarQube có thể phát hiện các lỗi coding convention, security và bug tiềm ẩn.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 15.3

            {
                question: "Để phân tích mã với SonarQube, bạn cần cài SonarScanner hoặc tích hợp plugin IDE.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 15.4

            {
                question: "SonarQube không hỗ trợ các ngôn ngữ lập trình phổ biến như Java, Python, JavaScript.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 16

            {
                question: "Kiểm thử phần mềm (Software Testing) là gì?",
                options: [
                    "A. Quá trình viết mã mới để test",
                    "B. Đánh giá chất lượng bằng cách thực thi phần mềm",
                    "C. Thiết kế hệ thống mạng",
                    "D. Triển khai ứng dụng bằng cách viết mã hạ tầng"
                ],
                answer: "B. Đánh giá chất lượng bằng cách thực thi phần mềm",
                type: "single_select"
            },
            // Câu 17

            {
                question: "Công cụ nào dùng để kiểm thử? (chọn nhiều đáp án)",
                options: ["A. Postman", "B. ZAP", "C. Jenkins", "D. Maven"],
                answer: ["A. Postman", "B. ZAP"],
                type: "multi_select"
            },
            // Câu 18.1

            {
                question: "Postman không hỗ trợ kiểm thử chuỗi các API liên tiếp (test flow logic), vì Postman không cho phép dùng Collection Runner.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 18.2

            {
                question: "OWASP ZAP là công cụ kiểm thử bảo mật ứng dụng web mã nguồn mở.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 18.3

            {
                question: "ZAP chỉ kiểm thử được ứng dụng được viết bằng Java.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 18.4

            {
                question: "ZAP là công cụ quét lỗ hổng HTTP/S, không phụ thuộc ngôn ngữ backend.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 19
            {
                question: "Phân tích mã nguồn tĩnh không thể phát hiện lỗi nào sau đây?",
                options: [
                    "A. Lỗi logic liên quan đến runtime input",
                    "B. Lỗi vi phạm coding standard",
                    "C. Các lỗ hổng bảo mật trong mã",
                    "D. Lỗi khai báo biến mà không dùng tới"
                ],
                answer: "A. Lỗi logic liên quan đến runtime input",
                type: "single_select"
            },
            // Câu 20
            {
                question: "Điểm khác biệt lớn nhất giữa kiểm thử phần mềm và phân tích mã nguồn tĩnh là gì?",
                options: [
                    "A. Kiểm thử cần thực thi phần mềm, phân tích mã thì không",
                    "B. Không có sự khác biệt nào",
                    "C. Kiểm thử tập trung vào bảo mật, còn phân tích mã thì không",
                    "D. Phân tích mã chạy thử phần mềm, kiểm thử không"
                ],
                answer: "A. Kiểm thử cần thực thi phần mềm, phân tích mã thì không",
                type: "single_select"
            },
            // CÂU 11
            {
                question: "Kéo giai đoạn trong quy trình DevOps vào đúng công cụ hỗ trợ tương ứng:",
                type: "drag_drop",
                categories: ["GitHub / GitLab", "SonarQube", "Postman", "OWASP ZAP"],
                items: [
                    { id: "item1", text: "Quản lý mã nguồn", correctCategory: "GitHub / GitLab" },
                    { id: "item2", text: "Phân tích mã nguồn tĩnh", correctCategory: "SonarQube" },
                    { id: "item3", text: "Kiểm thử API chức năng", correctCategory: "Postman" },
                    { id: "item4", text: "Kiểm thử bảo mật ứng dụng", correctCategory: "OWASP ZAP" }
                ]
            },
            // CÂU 12
            {
                question: "Kéo thả sao cho khớp công cụ với loại lỗi cần kiểm thử tương ứng:",
                type: "drag_drop",
                categories: ["OWASP ZAP", "Postman", "SonarQube"],
                items: [
                    { id: "item1", text: "Kiểm tra lỗ hổng như XSS, SQL Injection", correctCategory: "OWASP ZAP" },
                    { id: "item2", text: "Kiểm tra thời gian phản hồi API", correctCategory: "Postman" },
                    { id: "item3", text: "Kiểm tra code smell và bug logic", correctCategory: "SonarQube" }
                ]
            },
            // CÂU 13
            {
                question: "Kéo thả sao cho khớp đầu ra mong muốn và request tương ứng:",
                type: "drag_drop",
                categories: [
                    "GET https://api.example.com/users",
                    "POST https://api.example.com/users",
                    "DELETE https://api.example.com/users/5"
                ],
                items: [
                    { id: "item1", text: "Lấy danh sách người dùng", correctCategory: "GET https://api.example.com/users" },
                    { id: "item2", text: "Tạo người dùng mới", correctCategory: "POST https://api.example.com/users" },
                    { id: "item3", text: "Xoá người dùng theo ID", correctCategory: "DELETE https://api.example.com/users/5" }
                ]
            },
            // CÂU 14
            {
                question: "Kéo thả sao cho khớp giữa code kiểm thử JavaScript Postman với mục tiêu kiểm tra:",
                type: "drag_drop",
                categories: ["Kiểm tra API phản hồi thành công", "Kiểm tra login trả về token", "Kiểm tra hiệu năng phản hồi"],
                items: [
                    { id: "item1", text: "pm.response.code = 200", correctCategory: "Kiểm tra API phản hồi thành công" },
                    { id: "item2", text: "pm.expect(json.token).to.exist", correctCategory: "Kiểm tra login trả về token" },
                    { id: "item3", text: "pm.response.time < 1000", correctCategory: "Kiểm tra hiệu năng phản hồi" }
                ]
            },
            // CÂU 15
            {
                question: "Kéo thả sao cho khớp giữa loại tệp hoặc công nghệ mà SonarQube có thể phân tích (với plugin):",
                type: "drag_drop",
                categories: ["Có thể phân tích", "Không thể phân tích"],
                items: [
                    { id: "item1", text: "Java", correctCategory: "Có thể phân tích" },
                    { id: "item2", text: "YAML", correctCategory: "Có thể phân tích" },
                    { id: "item3", text: "Doc", correctCategory: "Không thể phân tích" }
                ]
            },
            // CÂU 24
            {
                question: "Kéo sao cho khớp công cụ với loại kiểm thử tương ứng:",
                type: "drag_drop",
                categories: ["SonarQube", "Postman", "OWASP ZAP"],
                items: [
                    { id: "item1", text: "Phân tích mã tĩnh (Static Analysis)", correctCategory: "SonarQube" },
                    { id: "item2", text: "Kiểm thử chức năng API (Functional Testing)", correctCategory: "Postman" },
                    { id: "item3", text: "Kiểm thử bảo mật (Security Testing)", correctCategory: "OWASP ZAP" }
                ]
            },
            // CÂU 25
            {
                question: "Kéo thả sao cho khớp công cụ với các giai đoạn trong chu trình DevOps:",
                type: "drag_drop",
                categories: ["Code", "Build", "Test", "Static code analysis"],
                items: [
                    { id: "item1", text: "Git/GitHub - Quản lý code", correctCategory: "Code" },
                    { id: "item2", text: "Jenkins/GitHub Actions", correctCategory: "Build" },
                    { id: "item3", text: "Postman, ZAP", correctCategory: "Test" },
                    { id: "item4", text: "SonarQube", correctCategory: "Static code analysis" }
                ]
            },
            // CÂU 27
            {
                question: "Kéo sao cho khớp giữa mã trạng thái HTTP và ý nghĩa phản hồi khi kiểm thử Postman:",
                type: "drag_drop",
                categories: ["200", "401", "500"],
                items: [
                    { id: "item1", text: "Thành công", correctCategory: "200" },
                    { id: "item2", text: "Không được ủy quyền (Unauthorized)", correctCategory: "401" },
                    { id: "item3", text: "Lỗi phía máy chủ (Server Error)", correctCategory: "500" }
                ]
            },
            // CÂU 29
            {
                question: "Kéo thả sao cho hành động khớp với công cụ tương ứng:",
                type: "drag_drop",
                categories: ["OWASP ZAP", "Postman", "SonarQube"],
                items: [
                    { id: "item1", text: "Quét bảo mật khi ứng dụng chạy trên môi trường staging/test", correctCategory: "OWASP ZAP" },
                    { id: "item2", text: "Tự động gửi API request và kiểm tra response", correctCategory: "Postman" },
                    { id: "item3", text: "Tự động quét mã nguồn sau khi push code", correctCategory: "SonarQube" }
                ]
            }

        ];
        let currentQuestionIndex = 0; // Chỉ số câu hỏi hiện tại
        let elapsedTime = 0; // Thời gian làm bài (giây)
        let timerInterval; // Biến lưu trữ Interval của đồng hồ
        let answeredQuestions = new Array(questions.length).fill(null);
        let correctnessStatus = new Array(questions.length).fill(null);
        // Lấy các phần tử DOM cần thiết
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const quizContent = document.getElementById('quiz-content');
        const questionCounter = document.getElementById('question-counter');
        const multiselectInfo = document.getElementById('multiselect-info');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const dragdropContainer = document.getElementById('dragdrop-container');
        const draggableItemsSource = document.getElementById('draggable-items-source');
        const dropTargetsContainer = document.getElementById('drop-targets-container');
        const fillInTheBlankContainer = document.getElementById('fill-in-the-blank-container');
        const fillInTheBlankInput = document.getElementById('fill-in-the-blank-input');
        const checkFillInTheBlankButton = document.getElementById('check-fill-in-the-blank-button');
        const checkAnswerButton = document.getElementById('check-answer-button'); // Nút kiểm tra chung (Multi-select, Drag & Drop)
        const nextButton = document.getElementById('next-button');
        const resultsScreen = document.getElementById('results-screen');
        const restartButton = document.getElementById('restart-button');
        // SỬA LỖI VÀ TÍNH ĐIỂM: Thêm các dòng này để khai báo biến DOM
        const resultMessage = document.getElementById('result-message'); 
        const exitButton = document.getElementById('exit-button'); 
        const finalScore = document.getElementById('final-score'); // Thẻ hiển thị điểm số
        
        const sidebar = document.getElementById('sidebar');
        const timerDisplay = document.getElementById('timer');
        const questionListContainer = document.getElementById('question-list-container');
        function normalizeString(str) {
            let normalized = str.toLowerCase().trim();
            normalized = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
            return normalized.replace(/\s+/g, '');
        }
        fillInTheBlankInput.onkeypress = (event) => {
            if (event.key === 'Enter') checkFillInTheBlank();
        };
        function drag(event) {
            event.dataTransfer.setData("text/plain", event.target.id);
            event.target.classList.add('opacity-50');
        }
        function dragEnd(event) {
            event.target.classList.remove('opacity-50');
        }
        function allowDrop(event) {
            event.preventDefault(); // Cho phép thả
            const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        function dragLeave(event) {
             const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        function drop(event, categoryName) {
            event.preventDefault();
            let targetZone = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            // Nếu đã kiểm tra (có feedback), không cho phép tương tác
            if (!targetZone || correctnessStatus[currentQuestionIndex] !== null) return; 
            targetZone.classList.remove('drag-over');
            const itemId = event.dataTransfer.getData("text/plain");
            const draggedElement = document.getElementById(itemId);
            if (draggedElement) {
                const oldParent = draggedElement.parentElement;
                if (oldParent) {
                    oldParent.removeChild(draggedElement);
                }
                targetZone.appendChild(draggedElement);
                let currentAnswer = answeredQuestions[currentQuestionIndex] || {};
                const itemText = draggedElement.textContent.trim(); 

                const isDroppedBackToSource = targetZone.id === 'draggable-items-source';

                if (isDroppedBackToSource) {
                    delete currentAnswer[itemText]; 
                } else { 
                    currentAnswer[itemText] = categoryName;
                }
                answeredQuestions[currentQuestionIndex] = Object.keys(currentAnswer).length > 0 ? currentAnswer : null;
                updateButtonStates();
            }
        }
        function checkCorrectness(questionIndex, selectedAnswers) {
            const currentQuestion = questions[questionIndex];
            if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = selectedAnswers || answeredQuestions[questionIndex];
                if (!droppedAnswers) return false;
                if (Object.keys(droppedAnswers).length !== currentQuestion.items.length) {
                    return false;
                }
                return currentQuestion.items.every(item => {
                    const droppedCategory = droppedAnswers[item.text];
                    return droppedCategory === item.correctCategory;
                });
            } else if (currentQuestion.type === "fill_in_the_blank") {
                 const userAnswer = selectedAnswers || answeredQuestions[questionIndex];
                 if (!userAnswer) return false;
                 const normalizedUserAnswer = normalizeString(userAnswer);
                 const normalizedCorrectAnswer = normalizeString(currentQuestion.answer);

                 return normalizedUserAnswer === normalizedCorrectAnswer;
            } else {
                const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                if (!Array.isArray(selectedAnswers)) {
                    selectedAnswers = selectedAnswers !== null ? [selectedAnswers] : [];
                }
                if (selectedAnswers.length !== correctAnswers.length) {
                    return false;
                }
                selectedAnswers.sort();
                correctAnswers.sort();
                return JSON.stringify(selectedAnswers) === JSON.stringify(correctAnswers);
            }
        }
        function showQuestion() {
            const currentQuestion = questions[currentQuestionIndex];
            questionCounter.textContent = `Câu hỏi: ${currentQuestionIndex + 1} / ${questions.length}`;
            questionText.innerHTML = currentQuestion.question;
            // ======= HIỂN THỊ HÌNH ẢNH MINH HỌA NẾU CÓ =======
            const imageContainer = document.getElementById("question-image-container");
            const imageElement = document.getElementById("question-image");
            if (currentQuestion.image) {
                imageElement.src = currentQuestion.image;
                imageContainer.classList.remove("hidden");
            } else {
                imageContainer.classList.add("hidden");
            }
            optionsContainer.classList.add('hidden');
            multiselectInfo.classList.add('hidden');
            dragdropContainer.classList.add('hidden');
            fillInTheBlankContainer.classList.add('hidden'); 
            checkAnswerButton.classList.add('hidden'); 
            if (currentQuestion.type === "drag_drop") {
                renderDragDropUI(currentQuestion);
                dragdropContainer.classList.remove('hidden');
            } else if (currentQuestion.type === "fill_in_the_blank") {
                renderFillInTheBlankUI(currentQuestion);
                fillInTheBlankContainer.classList.remove('hidden');
            } else {
                renderSelectUI(currentQuestion);
                optionsContainer.classList.remove('hidden');
            }
            nextButton.textContent = currentQuestionIndex >= questions.length - 1 ? "Hoàn thành bài thi" : "Câu tiếp theo";
            updateButtonStates();
            updateSidebarHighlight();
        }
        function renderSelectUI(currentQuestion) {
            const isMulti = currentQuestion.type === "multi_select";
            multiselectInfo.classList.toggle('hidden', !isMulti);
            checkAnswerButton.classList.toggle('hidden', !isMulti); // Hiển thị nút kiểm tra chỉ cho Multi-Select
            optionsContainer.innerHTML = '';
            const savedAnswer = answeredQuestions[currentQuestionIndex];
            const savedAnswersArray = Array.isArray(savedAnswer) ? savedAnswer : (savedAnswer !== null ? [savedAnswer] : []);
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option;
                let classes = [
                    "answer-button", "w-full", "py-3", "px-4", "rounded-xl", "text-center", 
                    "bg-gray-100", "border-2", "border-gray-300", 
                    "transition-all", "duration-200",
                    "font-medium", "text-gray-800", "shadow-sm"
                ];
                button.classList.add(...classes);
                if (isChecked) {
                    button.disabled = true;
                    button.classList.add("cursor-not-allowed");
                    const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                    const isCorrectOption = correctAnswers.includes(option);
                    const isUserSelected = savedAnswersArray.includes(option);
                    if (isCorrectOption) {
                        button.classList.add("bg-green-500", "text-white", "border-green-600");
                        button.classList.remove("bg-gray-100", "border-gray-300");
                    }
                    if (isUserSelected && !isCorrectOption) {
                        button.classList.add("bg-red-500", "text-white", "border-red-600");
                        button.classList.remove("bg-green-500", "border-green-600", "bg-gray-100", "border-gray-300");
                    }
                } else {
                    button.classList.add("hover:bg-blue-100", "hover:border-blue-500");
                    if (isMulti) {
                        button.addEventListener('click', (e) => {
                            toggleSelection(e.currentTarget);
                            updateButtonStates(); 
                        });
                    } else {
                        button.addEventListener('click', (e) => singleSelectCheck(option, e.currentTarget));
                    }
                    if (savedAnswersArray.includes(option)) {
                        button.classList.add('selected-option');
                    }
                }
                optionsContainer.appendChild(button);
            });
        }
        function renderFillInTheBlankUI(currentQuestion) {
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const savedAnswer = answeredQuestions[currentQuestionIndex] || "";
            fillInTheBlankInput.value = savedAnswer;
            fillInTheBlankInput.disabled = isChecked;
            fillInTheBlankInput.classList.remove('correct', 'incorrect');
            checkFillInTheBlankButton.classList.toggle('hidden', isChecked);
            if (isChecked) {
                const isCorrect = correctnessStatus[currentQuestionIndex];
                fillInTheBlankInput.classList.add(isCorrect ? 'correct' : 'incorrect');
                if (!isCorrect) {
                     fillInTheBlankInput.placeholder = `Đáp án đúng: ${currentQuestion.answer}`;
                }
            } else {
                fillInTheBlankInput.placeholder = "Nhập đáp án của bạn...";
            }
            updateButtonStates(); 
        }
        function checkFillInTheBlank() {
            const userAnswer = fillInTheBlankInput.value.trim();
            if (userAnswer === "") {
                showMessage("Vui lòng nhập đáp án vào ô trống.", "yellow");
                return;
            }// 1. Lưu đáp án
            answeredQuestions[currentQuestionIndex] = userAnswer;
            checkAndApplyFeedback(currentQuestionIndex); 
            fillInTheBlankInput.disabled = true;
            checkFillInTheBlankButton.classList.add('hidden');
            updateButtonStates(); 
        }// --- Render Logic cho Drag & Drop ---
        function renderDragDropUI(currentQuestion) {
            draggableItemsSource.innerHTML = '';
            dropTargetsContainer.innerHTML = '';
            const savedDrops = answeredQuestions[currentQuestionIndex] || {};
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const itemsDataMap = new Map(currentQuestion.items.map(item => [item.text, item]));
            checkAnswerButton.classList.remove('hidden');
            const sourcePlaceholder = document.createElement('p');
            sourcePlaceholder.classList.add('text-gray-500', 'text-sm', 'italic', 'w-full', 'source-placeholder');
            draggableItemsSource.ondragover = allowDrop;
            draggableItemsSource.ondragleave = dragLeave;
            if (!isChecked) {
                draggableItemsSource.ondrop = (e) => drop(e, null); 
                sourcePlaceholder.textContent = 'Kéo các thẻ ở đây... (Kéo thẻ từ ô đáp án về đây để "kéo ra")'; 
                sourcePlaceholder.classList.toggle('hidden', currentQuestion.items.length !== Object.keys(savedDrops).length);
            } else {
                draggableItemsSource.ondrop = null; // Vô hiệu hóa kéo/thả
                sourcePlaceholder.textContent = 'Đã hoàn thành.';
                sourcePlaceholder.classList.add('hidden'); 
            }
            draggableItemsSource.appendChild(sourcePlaceholder);
            const dropZones = {};
            currentQuestion.categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.classList.add('bg-gray-50', 'p-4', 'rounded-xl', 'shadow-md', 'flex', 'flex-col');
                const title = document.createElement('h3');
                title.textContent = category;
                title.classList.add('text-lg', 'font-bold', 'text-blue-700', 'mb-3', 'border-b', 'pb-2');
                categoryDiv.appendChild(title);
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone', 'flex', 'flex-wrap', 'gap-2', 'p-3', 'rounded-lg', 'flex-grow');
                dropZone.setAttribute('data-category', category);
                if (!isChecked) {
                    dropZone.ondragover = allowDrop;
                    dropZone.ondragleave = dragLeave;
                    dropZone.ondrop = (e) => drop(e, category); 
                } else {
                    dropZone.ondrop = null; 
                    dropZone.style.cursor = 'default';
                    const correctItemsForCategory = currentQuestion.items.filter(item => item.correctCategory === category);
                    const droppedItems = Object.entries(savedDrops)
                        .filter(([itemText, cat]) => cat === category)
                        .map(([itemText]) => itemText);
                    const correctlyPlacedCount = droppedItems.filter(text => itemsDataMap.get(text).correctCategory === category).length;
                    const incorrectlyPlacedCount = droppedItems.length - correctlyPlacedCount;
                    const missingCorrectCount = correctItemsForCategory.length - correctlyPlacedCount;
                    if (incorrectlyPlacedCount > 0 || missingCorrectCount > 0) {
                        dropZone.classList.add('incorrect-drop-zone');
                    } else if (correctlyPlacedCount > 0 && incorrectlyPlacedCount === 0 && missingCorrectCount === 0) {
                        dropZone.classList.add('correct-drop-zone');
                    }
                }
                dropTargetsContainer.appendChild(categoryDiv).appendChild(dropZone);
                dropZones[category] = dropZone;
            });
            currentQuestion.items.forEach(item => {
                const itemEl = createDraggableItem(item, isChecked);
                const droppedCategory = savedDrops[item.text];
                if (droppedCategory) {
                    const targetZone = dropZones[droppedCategory];
                    if (targetZone) {
                        targetZone.appendChild(itemEl);
                    }
                    if (isChecked) {
                        const isCorrect = droppedCategory === item.correctCategory;
                        itemEl.classList.remove('bg-white', 'border-gray-300');
                        itemEl.classList.add('text-gray-900', 'shadow-md', 'ring-2');
                        if (isCorrect) {
                            itemEl.classList.add('bg-green-200', 'ring-green-500');
                        } else {
                            itemEl.classList.add('bg-red-200', 'ring-red-500');
                            const correctHint = document.createElement('span');
                            correctHint.textContent = `(Đúng: ${item.correctCategory})`;
                            correctHint.classList.add('text-xs', 'text-red-700', 'mt-1', 'block', 'font-normal');
                            itemEl.appendChild(correctHint);
                        }
                    }
                } else {// Item chưa được thả -> Đặt vào vùng Source
                    draggableItemsSource.appendChild(itemEl);
                }
            });// Ẩn placeholder Source nếu không còn item nào
            const placeholder = draggableItemsSource.querySelector('.source-placeholder');
            if (placeholder) placeholder.classList.toggle('hidden', currentQuestion.items.length === Object.keys(savedDrops).length);
        }// Hàm tạo element cho thẻ kéo
        function createDraggableItem(item, isChecked) {
            const itemEl = document.createElement('div');
            itemEl.id = item.id;
            itemEl.textContent = item.text;
            itemEl.classList.add(
                'draggable-item', 'p-3', 'rounded-lg', 'shadow-sm', 'font-medium', 'text-sm', 'text-gray-800'
            );
            if (!isChecked) {
                itemEl.setAttribute('draggable', 'true');
                itemEl.ondragstart = drag;
                itemEl.ondragend = dragEnd;
            } else {
                itemEl.setAttribute('draggable', 'false');
                itemEl.style.cursor = 'default';
            }
            return itemEl;
        }// --- Logic Xử lý Đáp án (Select) ---
        function toggleSelection(button) {
            button.classList.toggle('selected-option');
        }
        function singleSelectCheck(selectedOption, button) {
            answeredQuestions[currentQuestionIndex] = selectedOption;
            checkAndApplyFeedback(currentQuestionIndex);
            renderSelectUI(questions[currentQuestionIndex]);
            updateButtonStates();
        }// Xử lý nút CHECK ANSWER (cho Multi-Select và Drag & Drop)
        checkAnswerButton.addEventListener('click', () => {
            const currentQuestion = questions[currentQuestionIndex];
            if (currentQuestion.type === "multi_select") {
                const allOptionButtons = optionsContainer.querySelectorAll('button');
                const selectedOptions = Array.from(allOptionButtons)
                    .filter(btn => btn.classList.contains('selected-option'))
                    .map(btn => btn.textContent);
                if (selectedOptions.length === 0) {
                    showMessage("Vui lòng chọn ít nhất một đáp án trước khi kiểm tra.", "yellow");
                    return;
                }// Lưu đáp án và kiểm tra
                answeredQuestions[currentQuestionIndex] = selectedOptions;
                checkAndApplyFeedback(currentQuestionIndex);
                renderSelectUI(questions[currentQuestionIndex]);
            } else if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = answeredQuestions[currentQuestionIndex];
                const isAllDropped = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                if (!isAllDropped) {
                    showMessage("Vui lòng kéo thả tất cả các thẻ vào vị trí trước khi kiểm tra.", "yellow");
                    return;
                }
                checkAndApplyFeedback(currentQuestionIndex);
                renderDragDropUI(questions[currentQuestionIndex]); // Render lại để hiển thị feedback
            }
            updateButtonStates();
        });
        // Hàm kiểm tra và áp dụng phản hồi
        function checkAndApplyFeedback(questionIndex) {
            const savedAnswer = answeredQuestions[questionIndex];
            const isCorrect = checkCorrectness(questionIndex, savedAnswer);
            const currentQuestionType = questions[questionIndex].type;
            if (isCorrect) {
                showMessage("🎉 Chúc mừng, đáp án chính xác!", "green");
            } else {
                if (currentQuestionType === "fill_in_the_blank") {
                     showMessage(`Sai rồi. Đáp án đúng là: ${questions[questionIndex].answer}.`, "red");
                } else if (currentQuestionType === "drag_drop") {
                     showMessage(`Sai rồi. Đáp án kéo thả chưa hoàn toàn chính xác. Vui lòng xem phản hồi màu sắc!`, "red");
                } else {
                     showMessage("Sai rồi. Vui lòng xem lại kết quả (Màu xanh lá là đúng, đỏ là sai)!", "red");
                }
            }
            correctnessStatus[questionIndex] = isCorrect;
            // Xử lý feedback cho Fill-in-the-Blank (cần gọi lại renderFillInTheBlankUI để update placeholder)
            if (currentQuestionType === "fill_in_the_blank") {
                renderFillInTheBlankUI(questions[questionIndex]);
            }
            updateSidebarHighlight(); // Cập nhật màu sắc trên sidebar
            return isCorrect;
        }
        function updateButtonStates() {
            const currentQuestion = questions[currentQuestionIndex];
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            nextButton.disabled = !isChecked;
            nextButton.classList.toggle('bg-gray-200', !isChecked);
            nextButton.classList.toggle('text-gray-800', !isChecked);
            nextButton.classList.toggle('enabled-next', isChecked);
            if (currentQuestion.type === "multi_select" || currentQuestion.type === "drag_drop") {
                checkAnswerButton.classList.toggle('hidden', isChecked);
                if (!isChecked) {
                    let isAnswered = false;
                    if (currentQuestion.type === "drag_drop") {
                        const droppedAnswers = answeredQuestions[currentQuestionIndex];
                        isAnswered = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                    } else if (currentQuestion.type === "multi_select") {
                        const currentSelections = optionsContainer.querySelectorAll('.selected-option').length;
                        isAnswered = currentSelections > 0;
                    }
                    checkAnswerButton.disabled = !isAnswered;
                    checkAnswerButton.classList.toggle('check-button-enabled', isAnswered);
                    checkAnswerButton.classList.toggle('check-button-disabled', !isAnswered);
                }
            }// 3. Logic cho nút CHECK FILL-IN-THE-BLANK
            if (currentQuestion.type === "fill_in_the_blank") {
                if (!isChecked) {
                    const isAnswered = fillInTheBlankInput.value.trim() !== "";
                    checkFillInTheBlankButton.disabled = !isAnswered;
                    checkFillInTheBlankButton.classList.toggle('check-button-enabled', isAnswered);
                    checkFillInTheBlankButton.classList.toggle('check-button-disabled', !isAnswered);
                    fillInTheBlankInput.oninput = updateButtonStates; 
                }
            }
        }
        nextButton.addEventListener('click', nextQuestion);
        function nextQuestion() {
            if (correctnessStatus[currentQuestionIndex] === null) {
                const currentType = questions[currentQuestionIndex].type;
                if (currentType === "multi_select" || currentType === "drag_drop" || currentType === "fill_in_the-blank") {
                    showMessage("Vui lòng nhấn nút 'Kiểm tra đáp án' trước khi chuyển câu.", "yellow");
                    return;
                }
            }// Chuyển sang câu tiếp theo (hoặc hoàn thành bài thi)
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }
        function jumpToQuestion(index) {
            currentQuestionIndex = index;
            showQuestion();
        }
        function goToStartScreen() {
            clearInterval(timerInterval);
            elapsedTime = 0; 
            timerDisplay.textContent = "00:00"; // Đặt lại đồng hồ hiển thị
            quizContent.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            sidebar.classList.add('hidden');
            startScreen.classList.remove('hidden');
        }
        function showResults() {
            clearInterval(timerInterval);
            quizContent.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            
            const totalCorrect = correctnessStatus.filter(status => status === true).length;
            const totalQuestions = questions.length;
            // TỐI ƯU HÓA TÍNH ĐIỂM: Cập nhật thẻ hiển thị điểm số
            finalScore.textContent = `${totalCorrect} / ${totalQuestions}`;
            if (totalCorrect === totalQuestions) {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Xin chúc mừng! Bạn đạt kết quả tuyệt đối.`;
            } else {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Hãy xem lại các câu trả lời của mình trên giao diện nhé.`;
            }
            sidebar.classList.add('hidden');
        }
        function restartQuiz() {
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            resultsScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden'); 
            startTimer();
            createQuestionList(); 
            showQuestion();
        }
        function startTimer() {
            clearInterval(timerInterval); 
            timerInterval = setInterval(() => {
                elapsedTime++;
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        function createQuestionList() {
            questionListContainer.innerHTML = '';
            questions.forEach((q, index) => {
                const button = document.createElement('button');
                button.textContent = index + 1;
                button.classList.add(
                    "w-8", "h-8", "rounded-full", "font-medium", "text-sm",
                    "bg-gray-200", "text-gray-800", "hover:bg-blue-200",
                    "transition-colors", "duration-200"
                );
                button.setAttribute('data-index', index);
                button.addEventListener('click', () => {
                    jumpToQuestion(index);
                });
                questionListContainer.appendChild(button);
            });
        }
        function updateSidebarHighlight() {
            const allQuestionButtons = questionListContainer.querySelectorAll('button');
            allQuestionButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'bg-green-500', 'bg-red-500', 'bg-yellow-400');
                const index = parseInt(btn.getAttribute('data-index'));
                if (index === currentQuestionIndex) {
                    btn.classList.add('bg-blue-600', 'text-white');
                } else if (correctnessStatus[index] === true) {
                    btn.classList.add('bg-green-500', 'text-white');
                } else if (correctnessStatus[index] === false) {
                    btn.classList.add('bg-red-500', 'text-white');
                } else if (answeredQuestions[index] !== null) {
                    btn.classList.add('bg-yellow-400', 'text-white');
                }
            });
        }
        function showMessage(text, color) {
            const existingMessage = quizContent.querySelector('.temp-message');
            if (existingMessage) existingMessage.remove();
            const colorClasses = {
                "yellow": "bg-yellow-100 border-yellow-400 text-yellow-700",
                "red": "bg-red-100 border-red-400 text-red-700",
                "green": "bg-green-100 border-green-400 text-green-700"
            };
            const messageBox = document.createElement('div');
            messageBox.textContent = text;
            const colorClassString = colorClasses[color] || colorClasses['yellow'];
            messageBox.classList.add(
                ...colorClassString.split(' '), 
                "border", "px-4", "py-3", "rounded", "relative", "mb-4", "temp-message"
            );
            quizContent.insertBefore(messageBox, questionCounter.nextElementSibling);
            setTimeout(() => messageBox.remove(), 3000); 
        }// --- Hàm XÁO TRỘN MẢNG (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            let shuffled = array.slice(); // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }// --- Khởi tạo sự kiện ---
        startButton.addEventListener('click', () => {
            // Đảm bảo reset trạng thái trước khi bắt đầu
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            // questions = shuffleArray(questions); // Xáo trộn câu hỏi
            startScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden');
            createQuestionList();
            startTimer();
            showQuestion();
        });
        restartButton.addEventListener('click', restartQuiz);
        exitButton.addEventListener('click', () => {
            showMessage("Đã thoát khỏi bài kiểm tra. Dữ liệu làm bài hiện tại sẽ không được lưu. Đang quay về màn hình bắt đầu...", "red");
            setTimeout(goToStartScreen, 1000);
        });
    </script>
</body>
</html>