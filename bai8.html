<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bài 8</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="css/test.css">
</head>
<body class="flex flex-col items-center justify-between min-h-screen bg-gray-100">
    <header >
        <h1 class="textheader">An Khùng</h1>
        <button id="exit-button" class="btnExit">Thoát</button>
        <a href="index.html" class="btnHome">
            <i class="fa-solid fa-arrow-left" style="color: rgb(0, 0, 0); font-size: 20px; font-weight: bold; margin-left: 8px;"></i>Trang Chủ.
        </a>
    </header>
    <!-- Container chính (Chia làm 2 cột trên màn hình lớn) -->
    <div class="container mx-auto px-4 my-8 grid grid-cols-1 md:grid-cols-10 gap-8 items-start">
        <!-- KHUNG BÊN TRÁI: NỘI DUNG CÂU HỎI (7/10 cột) -->
        <div id="quiz-container" class="bg-white p-8 rounded-2xl shadow-xl w-full md:col-span-7">
            <!-- Màn hình bắt đầu bài kiểm tra -->
            <div id="start-screen" class="text-center">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">Bài 8</h1>
                <p class="text-gray-600 mb-6">Chào mừng bạn đến với bài kiểm tra! Hãy nhấn "Bắt đầu" để bắt đầu.</p>
                <button id="start-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Bắt đầu</button>
            </div>
            <!-- Nội dung Quiz: Hiển thị câu hỏi và đáp án -->
            <div id="quiz-content" class="hidden">
                <!-- Bộ đếm câu hỏi (VD: 1/10) -->
                <p id="question-counter" class="text-lg font-semibold text-gray-700 mb-2"></p>
                <!-- Tiêu đề/Nội dung câu hỏi -->
                <h2 id="question-text" class="text-xl text-gray-1500 mb-2"></h2><br>
                <!-- Hình minh họa câu hỏi (nếu có) -->
                <div id="question-image-container" class="mb-4 hidden">
                    <img id="question-image" src="" alt="Minh họa câu hỏi" class="mx-auto rounded-xl shadow-lg max-h-64 object-contain">
                </div>
                <!-- Thông báo cho câu hỏi Multi-Select -->
                <p id="multiselect-info" class="text-sm text-red-500 font-medium mb-4 hidden"><i>2 đáp án đúng!</i></p>
                <!-- 1. Container cho Single/Multi-Select (Chọn đáp án) -->
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- Các nút đáp án được tạo bằng JavaScript -->
                </div>
                <!-- 2. Container cho Drag & Drop (Kéo thả) -->
                <div id="dragdrop-container" class="hidden">
                    <p class="text-sm text-blue-500 font-medium mb-4">Kéo thả theo ý đúng</p>
                    <!-- Vùng kéo (Source): Chứa các thẻ chưa được thả -->
                    <div id="draggable-items-source" class="source-drop-zone drop-zone flex flex-wrap gap-3 p-4 bg-gray-50 border rounded-xl mb-6 shadow-inner">
                        <p class="text-gray-500 text-sm italic w-full source-placeholder">Kéo các thẻ ở đây... </p>
                    </div>
                    <!-- Vùng thả (Targets): Chứa các Category -->
                    <div id="drop-targets-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    </div>
                </div>
                <!-- 3. Container cho Fill-in-the-Blank (Điền từ) -->
                <div id="fill-in-the-blank-container" class="space-y-4 hidden mt-6">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <input 
                            type="text" 
                            id="fill-in-the-blank-input" 
                            placeholder="Nhập đáp án của bạn..." 
                            class="flex-grow p-3 border border-gray-300 rounded-lg transition duration-150"
                        >
                        <button 
                            id="check-fill-in-the-blank-button"
                            class="check-button-enabled text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:bg-gray-400"
                            onclick="checkFillInTheBlank()"
                        >
                            Kiểm tra đáp án
                        </button>
                    </div>
                </div>
                <!-- Thanh điều hướng dưới cùng -->
                <div class="flex justify-end items-center mt-6 border-t pt-4 space-x-4">
                    <button 
                        id="check-answer-button" 
                        class="hidden text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105"
                    >
                        Kiểm tra
                    </button>
                    <button 
                        id="next-button" 
                        class="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-full shadow-md transition-all duration-300 transform hover:scale-105"
                    >
                        Tiếp
                    </button>
                </div>
            </div>
            <!-- Màn hình kết quả cuối bài thi -->
            <div id="results-screen" class="hidden text-center">
                <h2 class="text-3xl font-bold text-green-600 mb-4">Hoàn thành bài kiểm tra!</h2>
                <!-- HIỂN THỊ ĐIỂM SỐ ĐÃ TỐI ƯU HÓA -->
                <div class="bg-blue-50 p-6 rounded-2xl shadow-xl inline-block mb-6">
                    <p class="text-xl font-semibold text-gray-700">Điểm số của bạn:</p>
                    <!-- Thẻ hiển thị điểm số cuối cùng -->
                    <p id="final-score" class="text-6xl font-extrabold text-blue-700 mt-2">0 / 0</p>
                </div>
                <p id="result-message" class="text-gray-700 mb-6">Bạn có thể xem lại các câu trả lời của mình trên giao diện.</p>
                <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Làm lại</button>
            </div>
        </div>
        <!-- KHUNG BÊN PHẢI: SIDEBAR (3/10 cột) -->
        <div id="sidebar" class="bg-white p-6 rounded-2xl shadow-xl w-full hidden md:block md:col-span-3 sticky top-8">
            <div class="mb-6 text-center">
                <p class="text-xl font-semibold text-gray-700 mb-2">Thời gian làm bài:</p>
                <!-- Đồng hồ đếm ngược/đếm thời gian -->
                <div id="timer" class="text-4xl font-bold text-red-500">00:00</div>
            </div>
            <div>
                <p class="text-lg font-semibold text-gray-700 mb-4">Danh sách câu hỏi:</p>
                <!-- Danh sách các nút câu hỏi để nhảy qua lại -->
                <div id="question-list-container" class="grid grid-cols-4 gap-2">
                    <!-- Các nút câu hỏi được tạo bằng JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="w-full bg-gray-800 text-white text-center py-4 px-6 mt-auto">
        <p class="text-sm">&copy; Website luyện tập!!!</p>
    </footer>
    <script>
        let questions = [
            // Câu 1
            {
                question: "Trong quy trình phát triển liên tục, “pipeline” thường bao gồm những bước nào sau đây?",
                options: [
                    "A. Chỉ lấy mã và kiểm thử",
                    "B. Kiểm thử thủ công từ người dùng, phân tích mã nguồn tĩnh và biên dịch",
                    "C. Triển khai trực tiếp lên production mà không kiểm thử",
                    "D. Lấy mã nguồn, biên dịch, kiểm thử, triển khai"
                ],
                answer: "D. Lấy mã nguồn, biên dịch, kiểm thử, triển khai",
                type: "single_select"
            },

            // Câu 2
            {
                question: "Lợi ích chính của Continuous Deployment trong DevOps là gì?",
                options: [
                    "A. Đưa tính năng ra thị trường nhanh, ít can thiệp thủ công",
                    "B. Giảm chi phí thuê tester",
                    "C. Giảm áp lực bảo trì server",
                    "D. Tăng độ bao phủ kiểm thử UI"
                ],
                answer: "A. Đưa tính năng ra thị trường nhanh, ít can thiệp thủ công",
                type: "single_select"
            },
            // Câu 3.1
            {
                question: "Maven có thể được sử dụng để build ứng dụng và tạo artifact (file .jar/.war) phục vụ cho bước triển khai trong CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 3.2

            {
                question: "Trong CD, Maven thường chỉ dùng ở môi trường development, không có vai trò ở staging hay production.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 3.3

            {
                question: "Maven tạo ra artifact dùng để deploy ở bất kỳ môi trường nào.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 3.4

            {
                question: "File pom.xml trong Maven giúp định nghĩa cấu hình build, test và packaging cho ứng dụng Java.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },

            // Câu 4.1
            {
                question: "Docker giúp tạo môi trường triển khai ứng dụng nhất quán trong mọi giai đoạn từ dev đến production.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 4.2

            {
                question: "Dockerfile là một kịch bản giúp build container image có thể dùng trong bước deploy của CD pipeline.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 4.3

            {
                question: "CD không cần Docker vì chỉ có CI mới cần đóng gói ứng dụng.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 4.4

            {
                question: "Docker rất quan trọng trong CD để triển khai liên tục qua container.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },

            // Câu 5.1
            {
                question: "Các bước trong pipeline CD có thể là: docker build, docker push, và docker run.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 5.2

            {
                question: "Dockerfile là một công cụ kiểm thử hiệu năng ứng dụng.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 5.3

            {
                question: "Docker là một hệ điều hành chạy trên máy ảo VM.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 5.4

            {
                question: "Trong thực tế DevOps, kết hợp Maven + Docker là mô hình phổ biến trong việc build → package → deploy tự động.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },

            // Câu 6.1
            {
                question: "Lệnh mvn install trong Maven sẽ tạo ra file .jar hoặc .war dùng cho bước deploy trong CD pipeline.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 6.2

            {
                question: "Git không phù hợp để quản lý mã nguồn trong môi trường triển khai liên tục vì thiếu khả năng phân nhánh.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 6.3

            {
                question: "Jenkins được sử dụng trong CD để tự động hóa toàn bộ quá trình build, test và deploy.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 6.4

            {
                question: "Pull request trên GitHub có thể được cấu hình để chạy tự động pipeline CD với Jenkins hoặc GitHub Actions.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },

            // Câu 7.1
            {
                question: "Trong pipeline Jenkins, ta có thể cấu hình lệnh sh 'mvn sonar:sonar' để phân tích mã bằng SonarQube.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 7.2

            {
                question: "SonarQube chỉ phân tích mã JavaScript, không hỗ trợ mã Java.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 7.3

            {
                question: "Nexus có thể hoạt động như một kho lưu trữ artifact để phục vụ cho triển khai CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 7.4

            {
                question: "Jenkins không thể thực hiện deploy lên nhiều môi trường như test, staging, production trong cùng một pipeline.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },

            // Câu 8
            {
                question: "Lợi ích của việc đóng gói ứng dụng dưới dạng Docker image trong pipeline DevOps là gì? (chọn 3 đap án đúng)",
                options: [
                    "A. Đảm bảo môi trường triển khai nhất quán từ dev đến production",
                    "B. Tăng kích thước ứng dụng để dễ debug",
                    "C. Dễ dàng tích hợp với CI/CD pipeline",
                    "D. Dễ dàng tích hợp với CI/CD pipelines"
                ],
                answer: [
                    "A. Đảm bảo môi trường triển khai nhất quán từ dev đến production",
                    "C. Dễ dàng tích hợp với CI/CD pipeline",
                    "D. Dễ dàng tích hợp với CI/CD pipelines"
                ],
                type: "multi_select"
            },

            // Câu 9
            {
                question: "Lệnh nào được sử dụng trong CD pipeline để tạo ra image từ Dockerfile?",
                options: [
                    "A. docker build",
                    "B. docker run",
                    "C. docker pull",
                    "D. docker push"
                ],
                answer: "A. docker build",
                type: "single_select"
            },
            //Câu 10
            {
                question: "Trong Jenkinsfile, muốn sử dụng Docker để build image, ta cần thực hiện những bước nào? (3 bước đúng)",
                options: [
                    "A. Dùng lệnh mvn clean Install thay thế hoàn toàn cho Docker",
                    "B. Khai báo agent docker",
                    "C. Cài Docker trên Jenkins agent",
                    "D. Dùng sh ‘docker build -t my-image.’ trong stage"
                ],
                answer: [
                    "B. Khai báo agent docker",
                    "C. Cài Docker trên Jenkins agent",
                    "D. Dùng sh ‘docker build -t my-image.’ trong stage"
                ],
                type: "multi_select"
            },
            // Câu 11
            {
                question: "Trong DevOps CD pipeline, khi nào nên tạo Docker image mới? (chọn 3 đap án đúng)",
                options: [
                    "A. Mỗi lần có commit mới vào nhánh chính",
                    "B. Sau mỗi lần build thành công",
                    "C. Chỉ khi deploy lên môi trường production",
                    "D. Khi có thay đổi trong Dockerfile hoặc mã nguồn ứng dụng"
                ],
                answer: [
                    "A. Mỗi lần có commit mới vào nhánh chính",
                    "B. Sau mỗi lần build thành công",
                    "D. Khi có thay đổi trong Dockerfile hoặc mã nguồn ứng dụng"
                ],
                type: "multi_select"
            },
            // Câu 16
            {
                question: "Trong DevOps, CD là viết tắt của từ nào sau đây?",
                options: [
                    "A. Continuous Development",
                    "B. Continuous Delivery",
                    "C. Continuous Debugging",
                    "D. Continuous Delete"
                ],
                answer: "B. Continuous Delivery",
                type: "single_select"
            },
            // Câu 17
            {
                question: "Khác biệt chính giữa Continuous Delivery và Continuous Development là gì?",
                options: [
                    "A. Continuous Delivery không sử dụng CI/CD",
                    "B. Continuous Delivery yêu cầu triển khai thủ công ra production",
                    "C. Continuous Development không cần kiểm thử",
                    "D. Continuous Development cần người xác nhận và không thể triển khai tự động vì liên quan đến vấn đề bảo mật"
                ],
                answer: "B. Continuous Delivery yêu cầu triển khai thủ công ra production",
                type: "single_select"
            },
            // Câu 18.1
            {
                question: "Lệnh mvn deploy có thể được dùng để gửi artifact lên repository như Nexus.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 18.2
            {
                question: "Maven hỗ trợ tích hợp với Jenkins để làm một phần của pipeline CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 18.3
            {
                question: "Maven không thể chạy các kiểm thử đơn vị (unit test) trước khi đóng gói ứng dụng.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 18.4
            {
                question: "Trong quy trình CD, Maven có thể được dùng để tạo phiên bản (version) cho các bản phát hành bằng lệnh mvn release:prepare.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 19.1
            {
                question: "Trong quy trình CD, việc quản lý phiên bản ứng dụng bằng Git là yếu tố quan trọng để đảm bảo khả năng rollback khi cần.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 19.2
            {
                question: "GitHub hỗ trợ webhook, dùng để kích hoạt Jenkins hoặc GitHub Actions.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 19.3
            {
                question: "Trong quy trình CD, Maven giúp tự động hóa việc build, test, và đóng gói ứng dụng Java.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 19.4
            {
                question: "GitHub không hỗ trợ webhook để tự động kích hoạt pipeline CD sau khi code được push.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            //Câu 20 
            {
                question: "Những thành phần chính trong một Dockerfile là gì? (chọn 3 đáp án đúng)",
                options: [
                    "A. FROM",
                    "B. HELPING",
                    "C. CMD",
                    "D. RUN"
                ],
                answer: [
                    "A. FROM",
                    "C. CMD",
                    "D. RUN"
                ],
                type: "multi_select"
            },
            // Câu 23
            {
                question: "Giai đoạn nào sau đây là đặc trưng của CD nhưng không bắt buộc có trong CI?",
                options: [
                    "A. Build và kiểm thử tự động",
                    "B. Deploy lên môi trường staging hoặc production",
                    "C. Unit test (kiểm thử đơn vị)",
                    "D. Merge code vào nhánh chính"
                ],
                answer: "B. Deploy lên môi trường staging hoặc production",
                type: "single_select"
            },
            // Câu 24.1
            {
                question: "Trong quy trình CD, Docker có thể dùng để build image sau khi Maven tạo ra .jar file.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 24.2
            {
                question: "Docker Compose rất hữu ích trong các môi trường staging/local.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 24.3
            {
                question: "Docker Compose không phù hợp để kiểm thử tích hợp trong môi trường staging của CD pipeline.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 24.4
            {
                question: "Docker image đã được kiểm thử thành công có thể đẩy được lên Docker Registry như DockerHub trong giai đoạn CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 25.1
            {
                question: "Docker giúp đóng gói ứng dụng và môi trường phụ thuộc thành một image có thể deploy được trên bất kỳ máy chủ nào.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 25.2
            {
                question: "Lệnh docker build được sử dụng để tạo Docker image cho ứng dụng đã được build bằng Maven.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 25.3
            {
                question: "Postman chỉ hỗ trợ test thủ công, không dùng được trong pipeline CI/CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 25.4
            {
                question: "Trong quy trình CD, các bài test API có thể được viết và chạy tự động bằng Postman và công cụ dòng lệnh Newman.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 26
            {
                question: "Làm thế nào để đẩy Docker image lên kho chứa để phục vụ triển khai CD?",
                options: [
                    "A. Gắn thẻ (tag) image không theo đúng định dạng",
                    "B. Xóa file pom.xml trong dự án Maven",
                    "C. Sử dụng docker push",
                    "D. Sử dụng lệnh clone để đẩy"
                ],
                answer: "C. Sử dụng docker push",
                type: "single_select"
            },
            // Câu 27.1
            {
                question: "Để đảm bảo artifact nhất quán, việc đóng gói ứng dụng bằng Maven cần kết hợp với hệ quản lý phiên bản như Git, GitHub.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 27.2
            {
                question: "Maven có plugin để gọi sonar:sonar rất phổ biến trong CI/CD.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 27.3
            {
                question: "Artifact tạo ra từ Maven có thể được dùng trực tiếp trong Docker build để đóng container image.",
                options: ["A. Đúng", "B. Sai"],
                answer: "A. Đúng",
                type: "single_select"
            },
            // Câu 27.4
            {
                question: "Maven không thể làm việc với SonarQube để thực hiện phân tích mã trong pipeline CD",
                options: ["A. Đúng", "B. Sai"],
                answer: "B. Sai",
                type: "single_select"
            },
            // Câu 28
            {
                question: "Các công cụ phổ biến dùng để lưu trữ Docker image là gì? <(chọn 3 đap án đúng)",
                options: [
                    "A. Google Container Registry (GCR)",
                    "B. AWS ECR",
                    "C. DockerHub",
                    "D. GitHub Pages"
                ],
                answer: [
                    "A. Google Container Registry (GCR)",
                    "B. AWS ECR",
                    "C. DockerHub"
                ],
                type: "multi_select"
            },
            // CÂU HỎI KÉO THẢ (DRAG & DROP)
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Trong Jenkins, để triển khai ứng dụng tự động hóa theo CD, bạn cần viết một tập lệnh gọi là __(1)___. Trong Jenkins, block __(2)__ định nghĩa các bước triển khai trong từng giai đoạn của CD pipeline.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "Jenkinsfile", correctCategory: "(1)" },
                    { id: "item2", text: "stages", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Plugin __(1)__ trong Jenkins giúp tích hợp với hệ thống phân tích mã như SonarQube. Để deploy ứng dụng đã build lên máy chủ hoặc container, Jenkins thường dùng lệnh __(2)__.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "SonarQube Scanner", correctCategory: "(1)" },
                    { id: "item2", text: "sh", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Lệnh Docker __(1)__ dùng để tải image từ Docker Hub về máy cục bộ. Để tạo container mới từ image và chạy nó, ta dùng lệnh docker __(2)__.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "pull", correctCategory: "(1)" },
                    { id: "item2", text: "run", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Để gắn tên (tag) cho một Docker image, sử dụng lệnh docker __(1)__. Nếu muốn xóa một container đang dừng, bạn dùng lệnh docker __(2)__.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "tag", correctCategory: "(1)" },
                    { id: "item2", text: "rm", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Sau khi kiểm thử và phân tích mã, CD pipeline có thể sử dụng bước deploy để triển khai ứng dụng lên __(1)__ hoặc production. Để triển khai artifact ra các môi trường, Jenkins có thể lấy file .jar hoặc .war từ lệnh Maven __(2)__.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "staging", correctCategory: "(1)" },
                    { id: "item2", text: "package", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Lệnh docker __(1)__ -t my-image . được dùng để build Docker image từ Dockerfile. Lệnh docker __(2)__ my-image dùng để đẩy image lên Docker Hub hoặc registry nội bộ.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "build", correctCategory: "(1)" },
                    { id: "item2", text: "push", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Lệnh archiveArtifacts artifacts: '**/target/*.jar' được dùng để lưu file build trong bước __(1)__. Để CD pipeline được kích hoạt tự động khi có thay đổi trên GitHub, bạn cần cấu hình __(2)__ trong GitHub repo.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "post-build", correctCategory: "(1)" },
                    { id: "item2", text: "webhook", correctCategory: "(2)" },
                ]
            },
            {
                question: "Kéo thả các thông tin phù hợp vào các chỗ trống trong phát biểu sau: Để xem danh sách container đang chạy, dùng lệnh docker __(1)__. Lệnh docker __(2)__ cho phép bạn đăng nhập vào Docker Registry trước khi push/pull.",
                type: "drag_drop",
                categories: ["(1)", "(2)"],
                items: [
                    { id: "item1", text: "ps", correctCategory: "(1)" },
                    { id: "item2", text: "login", correctCategory: "(2)" },
                ]
            },

        ];
        let currentQuestionIndex = 0; // Chỉ số câu hỏi hiện tại
        let elapsedTime = 0; // Thời gian làm bài (giây)
        let timerInterval; // Biến lưu trữ Interval của đồng hồ
        let answeredQuestions = new Array(questions.length).fill(null);
        let correctnessStatus = new Array(questions.length).fill(null);
        // Lấy các phần tử DOM cần thiết
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const quizContent = document.getElementById('quiz-content');
        const questionCounter = document.getElementById('question-counter');
        const multiselectInfo = document.getElementById('multiselect-info');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const dragdropContainer = document.getElementById('dragdrop-container');
        const draggableItemsSource = document.getElementById('draggable-items-source');
        const dropTargetsContainer = document.getElementById('drop-targets-container');
        const fillInTheBlankContainer = document.getElementById('fill-in-the-blank-container');
        const fillInTheBlankInput = document.getElementById('fill-in-the-blank-input');
        const checkFillInTheBlankButton = document.getElementById('check-fill-in-the-blank-button');
        const checkAnswerButton = document.getElementById('check-answer-button'); // Nút kiểm tra chung (Multi-select, Drag & Drop)
        const nextButton = document.getElementById('next-button');
        const resultsScreen = document.getElementById('results-screen');
        const restartButton = document.getElementById('restart-button');
        // SỬA LỖI VÀ TÍNH ĐIỂM: Thêm các dòng này để khai báo biến DOM
        const resultMessage = document.getElementById('result-message'); 
        const exitButton = document.getElementById('exit-button'); 
        const finalScore = document.getElementById('final-score'); // Thẻ hiển thị điểm số
        
        const sidebar = document.getElementById('sidebar');
        const timerDisplay = document.getElementById('timer');
        const questionListContainer = document.getElementById('question-list-container');
        function normalizeString(str) {
            let normalized = str.toLowerCase().trim();
            normalized = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
            return normalized.replace(/\s+/g, '');
        }
        fillInTheBlankInput.onkeypress = (event) => {
            if (event.key === 'Enter') checkFillInTheBlank();
        };
        function drag(event) {
            event.dataTransfer.setData("text/plain", event.target.id);
            event.target.classList.add('opacity-50');
        }
        function dragEnd(event) {
            event.target.classList.remove('opacity-50');
        }
        function allowDrop(event) {
            event.preventDefault(); // Cho phép thả
            const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        function dragLeave(event) {
             const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        function drop(event, categoryName) {
            event.preventDefault();
            let targetZone = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            // Nếu đã kiểm tra (có feedback), không cho phép tương tác
            if (!targetZone || correctnessStatus[currentQuestionIndex] !== null) return; 
            targetZone.classList.remove('drag-over');
            const itemId = event.dataTransfer.getData("text/plain");
            const draggedElement = document.getElementById(itemId);
            if (draggedElement) {
                const oldParent = draggedElement.parentElement;
                if (oldParent) {
                    oldParent.removeChild(draggedElement);
                }
                targetZone.appendChild(draggedElement);
                let currentAnswer = answeredQuestions[currentQuestionIndex] || {};
                const itemText = draggedElement.textContent.trim(); 

                const isDroppedBackToSource = targetZone.id === 'draggable-items-source';

                if (isDroppedBackToSource) {
                    delete currentAnswer[itemText]; 
                } else { 
                    currentAnswer[itemText] = categoryName;
                }
                answeredQuestions[currentQuestionIndex] = Object.keys(currentAnswer).length > 0 ? currentAnswer : null;
                updateButtonStates();
            }
        }
        function checkCorrectness(questionIndex, selectedAnswers) {
            const currentQuestion = questions[questionIndex];
            if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = selectedAnswers || answeredQuestions[questionIndex];
                if (!droppedAnswers) return false;
                if (Object.keys(droppedAnswers).length !== currentQuestion.items.length) {
                    return false;
                }
                return currentQuestion.items.every(item => {
                    const droppedCategory = droppedAnswers[item.text];
                    return droppedCategory === item.correctCategory;
                });
            } else if (currentQuestion.type === "fill_in_the_blank") {
                 const userAnswer = selectedAnswers || answeredQuestions[questionIndex];
                 if (!userAnswer) return false;
                 const normalizedUserAnswer = normalizeString(userAnswer);
                 const normalizedCorrectAnswer = normalizeString(currentQuestion.answer);

                 return normalizedUserAnswer === normalizedCorrectAnswer;
            } else {
                const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                if (!Array.isArray(selectedAnswers)) {
                    selectedAnswers = selectedAnswers !== null ? [selectedAnswers] : [];
                }
                if (selectedAnswers.length !== correctAnswers.length) {
                    return false;
                }
                selectedAnswers.sort();
                correctAnswers.sort();
                return JSON.stringify(selectedAnswers) === JSON.stringify(correctAnswers);
            }
        }
        function showQuestion() {
            const currentQuestion = questions[currentQuestionIndex];
            questionCounter.textContent = `Câu hỏi: ${currentQuestionIndex + 1} / ${questions.length}`;
            questionText.innerHTML = currentQuestion.question;
            // ======= HIỂN THỊ HÌNH ẢNH MINH HỌA NẾU CÓ =======
            const imageContainer = document.getElementById("question-image-container");
            const imageElement = document.getElementById("question-image");
            if (currentQuestion.image) {
                imageElement.src = currentQuestion.image;
                imageContainer.classList.remove("hidden");
            } else {
                imageContainer.classList.add("hidden");
            }
            optionsContainer.classList.add('hidden');
            multiselectInfo.classList.add('hidden');
            dragdropContainer.classList.add('hidden');
            fillInTheBlankContainer.classList.add('hidden'); 
            checkAnswerButton.classList.add('hidden'); 
            if (currentQuestion.type === "drag_drop") {
                renderDragDropUI(currentQuestion);
                dragdropContainer.classList.remove('hidden');
            } else if (currentQuestion.type === "fill_in_the_blank") {
                renderFillInTheBlankUI(currentQuestion);
                fillInTheBlankContainer.classList.remove('hidden');
            } else {
                renderSelectUI(currentQuestion);
                optionsContainer.classList.remove('hidden');
            }
            nextButton.textContent = currentQuestionIndex >= questions.length - 1 ? "Hoàn thành bài thi" : "Câu tiếp theo";
            updateButtonStates();
            updateSidebarHighlight();
        }
        function renderSelectUI(currentQuestion) {
            const isMulti = currentQuestion.type === "multi_select";
            multiselectInfo.classList.toggle('hidden', !isMulti);
            checkAnswerButton.classList.toggle('hidden', !isMulti); // Hiển thị nút kiểm tra chỉ cho Multi-Select
            optionsContainer.innerHTML = '';
            const savedAnswer = answeredQuestions[currentQuestionIndex];
            const savedAnswersArray = Array.isArray(savedAnswer) ? savedAnswer : (savedAnswer !== null ? [savedAnswer] : []);
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option;
                let classes = [
                    "answer-button", "w-full", "py-3", "px-4", "rounded-xl", "text-center", 
                    "bg-gray-100", "border-2", "border-gray-300", 
                    "transition-all", "duration-200",
                    "font-medium", "text-gray-800", "shadow-sm"
                ];
                button.classList.add(...classes);
                if (isChecked) {
                    button.disabled = true;
                    button.classList.add("cursor-not-allowed");
                    const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                    const isCorrectOption = correctAnswers.includes(option);
                    const isUserSelected = savedAnswersArray.includes(option);
                    if (isCorrectOption) {
                        button.classList.add("bg-green-500", "text-white", "border-green-600");
                        button.classList.remove("bg-gray-100", "border-gray-300");
                    }
                    if (isUserSelected && !isCorrectOption) {
                        button.classList.add("bg-red-500", "text-white", "border-red-600");
                        button.classList.remove("bg-green-500", "border-green-600", "bg-gray-100", "border-gray-300");
                    }
                } else {
                    button.classList.add("hover:bg-blue-100", "hover:border-blue-500");
                    if (isMulti) {
                        button.addEventListener('click', (e) => {
                            toggleSelection(e.currentTarget);
                            updateButtonStates(); 
                        });
                    } else {
                        button.addEventListener('click', (e) => singleSelectCheck(option, e.currentTarget));
                    }
                    if (savedAnswersArray.includes(option)) {
                        button.classList.add('selected-option');
                    }
                }
                optionsContainer.appendChild(button);
            });
        }
        function renderFillInTheBlankUI(currentQuestion) {
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const savedAnswer = answeredQuestions[currentQuestionIndex] || "";
            fillInTheBlankInput.value = savedAnswer;
            fillInTheBlankInput.disabled = isChecked;
            fillInTheBlankInput.classList.remove('correct', 'incorrect');
            checkFillInTheBlankButton.classList.toggle('hidden', isChecked);
            if (isChecked) {
                const isCorrect = correctnessStatus[currentQuestionIndex];
                fillInTheBlankInput.classList.add(isCorrect ? 'correct' : 'incorrect');
                if (!isCorrect) {
                     fillInTheBlankInput.placeholder = `Đáp án đúng: ${currentQuestion.answer}`;
                }
            } else {
                fillInTheBlankInput.placeholder = "Nhập đáp án của bạn...";
            }
            updateButtonStates(); 
        }
        function checkFillInTheBlank() {
            const userAnswer = fillInTheBlankInput.value.trim();
            if (userAnswer === "") {
                showMessage("Vui lòng nhập đáp án vào ô trống.", "yellow");
                return;
            }// 1. Lưu đáp án
            answeredQuestions[currentQuestionIndex] = userAnswer;
            checkAndApplyFeedback(currentQuestionIndex); 
            fillInTheBlankInput.disabled = true;
            checkFillInTheBlankButton.classList.add('hidden');
            updateButtonStates(); 
        }// --- Render Logic cho Drag & Drop ---
        function renderDragDropUI(currentQuestion) {
            draggableItemsSource.innerHTML = '';
            dropTargetsContainer.innerHTML = '';
            const savedDrops = answeredQuestions[currentQuestionIndex] || {};
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const itemsDataMap = new Map(currentQuestion.items.map(item => [item.text, item]));
            checkAnswerButton.classList.remove('hidden');
            const sourcePlaceholder = document.createElement('p');
            sourcePlaceholder.classList.add('text-gray-500', 'text-sm', 'italic', 'w-full', 'source-placeholder');
            draggableItemsSource.ondragover = allowDrop;
            draggableItemsSource.ondragleave = dragLeave;
            if (!isChecked) {
                draggableItemsSource.ondrop = (e) => drop(e, null); 
                sourcePlaceholder.textContent = 'Kéo các thẻ ở đây... (Kéo thẻ từ ô đáp án về đây để "kéo ra")'; 
                sourcePlaceholder.classList.toggle('hidden', currentQuestion.items.length !== Object.keys(savedDrops).length);
            } else {
                draggableItemsSource.ondrop = null; // Vô hiệu hóa kéo/thả
                sourcePlaceholder.textContent = 'Đã hoàn thành.';
                sourcePlaceholder.classList.add('hidden'); 
            }
            draggableItemsSource.appendChild(sourcePlaceholder);
            const dropZones = {};
            currentQuestion.categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.classList.add('bg-gray-50', 'p-4', 'rounded-xl', 'shadow-md', 'flex', 'flex-col');
                const title = document.createElement('h3');
                title.textContent = category;
                title.classList.add('text-lg', 'font-bold', 'text-blue-700', 'mb-3', 'border-b', 'pb-2');
                categoryDiv.appendChild(title);
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone', 'flex', 'flex-wrap', 'gap-2', 'p-3', 'rounded-lg', 'flex-grow');
                dropZone.setAttribute('data-category', category);
                if (!isChecked) {
                    dropZone.ondragover = allowDrop;
                    dropZone.ondragleave = dragLeave;
                    dropZone.ondrop = (e) => drop(e, category); 
                } else {
                    dropZone.ondrop = null; 
                    dropZone.style.cursor = 'default';
                    const correctItemsForCategory = currentQuestion.items.filter(item => item.correctCategory === category);
                    const droppedItems = Object.entries(savedDrops)
                        .filter(([itemText, cat]) => cat === category)
                        .map(([itemText]) => itemText);
                    const correctlyPlacedCount = droppedItems.filter(text => itemsDataMap.get(text).correctCategory === category).length;
                    const incorrectlyPlacedCount = droppedItems.length - correctlyPlacedCount;
                    const missingCorrectCount = correctItemsForCategory.length - correctlyPlacedCount;
                    if (incorrectlyPlacedCount > 0 || missingCorrectCount > 0) {
                        dropZone.classList.add('incorrect-drop-zone');
                    } else if (correctlyPlacedCount > 0 && incorrectlyPlacedCount === 0 && missingCorrectCount === 0) {
                        dropZone.classList.add('correct-drop-zone');
                    }
                }
                dropTargetsContainer.appendChild(categoryDiv).appendChild(dropZone);
                dropZones[category] = dropZone;
            });
            currentQuestion.items.forEach(item => {
                const itemEl = createDraggableItem(item, isChecked);
                const droppedCategory = savedDrops[item.text];
                if (droppedCategory) {
                    const targetZone = dropZones[droppedCategory];
                    if (targetZone) {
                        targetZone.appendChild(itemEl);
                    }
                    if (isChecked) {
                        const isCorrect = droppedCategory === item.correctCategory;
                        itemEl.classList.remove('bg-white', 'border-gray-300');
                        itemEl.classList.add('text-gray-900', 'shadow-md', 'ring-2');
                        if (isCorrect) {
                            itemEl.classList.add('bg-green-200', 'ring-green-500');
                        } else {
                            itemEl.classList.add('bg-red-200', 'ring-red-500');
                            const correctHint = document.createElement('span');
                            correctHint.textContent = `(Đúng: ${item.correctCategory})`;
                            correctHint.classList.add('text-xs', 'text-red-700', 'mt-1', 'block', 'font-normal');
                            itemEl.appendChild(correctHint);
                        }
                    }
                } else {// Item chưa được thả -> Đặt vào vùng Source
                    draggableItemsSource.appendChild(itemEl);
                }
            });// Ẩn placeholder Source nếu không còn item nào
            const placeholder = draggableItemsSource.querySelector('.source-placeholder');
            if (placeholder) placeholder.classList.toggle('hidden', currentQuestion.items.length === Object.keys(savedDrops).length);
        }// Hàm tạo element cho thẻ kéo
        function createDraggableItem(item, isChecked) {
            const itemEl = document.createElement('div');
            itemEl.id = item.id;
            itemEl.textContent = item.text;
            itemEl.classList.add(
                'draggable-item', 'p-3', 'rounded-lg', 'shadow-sm', 'font-medium', 'text-sm', 'text-gray-800'
            );
            if (!isChecked) {
                itemEl.setAttribute('draggable', 'true');
                itemEl.ondragstart = drag;
                itemEl.ondragend = dragEnd;
            } else {
                itemEl.setAttribute('draggable', 'false');
                itemEl.style.cursor = 'default';
            }
            return itemEl;
        }// --- Logic Xử lý Đáp án (Select) ---
        function toggleSelection(button) {
            button.classList.toggle('selected-option');
        }
        function singleSelectCheck(selectedOption, button) {
            answeredQuestions[currentQuestionIndex] = selectedOption;
            checkAndApplyFeedback(currentQuestionIndex);
            renderSelectUI(questions[currentQuestionIndex]);
            updateButtonStates();
        }// Xử lý nút CHECK ANSWER (cho Multi-Select và Drag & Drop)
        checkAnswerButton.addEventListener('click', () => {
            const currentQuestion = questions[currentQuestionIndex];
            if (currentQuestion.type === "multi_select") {
                const allOptionButtons = optionsContainer.querySelectorAll('button');
                const selectedOptions = Array.from(allOptionButtons)
                    .filter(btn => btn.classList.contains('selected-option'))
                    .map(btn => btn.textContent);
                if (selectedOptions.length === 0) {
                    showMessage("Vui lòng chọn ít nhất một đáp án trước khi kiểm tra.", "yellow");
                    return;
                }// Lưu đáp án và kiểm tra
                answeredQuestions[currentQuestionIndex] = selectedOptions;
                checkAndApplyFeedback(currentQuestionIndex);
                renderSelectUI(questions[currentQuestionIndex]);
            } else if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = answeredQuestions[currentQuestionIndex];
                const isAllDropped = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                if (!isAllDropped) {
                    showMessage("Vui lòng kéo thả tất cả các thẻ vào vị trí trước khi kiểm tra.", "yellow");
                    return;
                }
                checkAndApplyFeedback(currentQuestionIndex);
                renderDragDropUI(questions[currentQuestionIndex]); // Render lại để hiển thị feedback
            }
            updateButtonStates();
        });
        // Hàm kiểm tra và áp dụng phản hồi
        function checkAndApplyFeedback(questionIndex) {
            const savedAnswer = answeredQuestions[questionIndex];
            const isCorrect = checkCorrectness(questionIndex, savedAnswer);
            const currentQuestionType = questions[questionIndex].type;
            if (isCorrect) {
                showMessage("🎉 Chúc mừng, đáp án chính xác!", "green");
            } else {
                if (currentQuestionType === "fill_in_the_blank") {
                     showMessage(`Sai rồi. Đáp án đúng là: ${questions[questionIndex].answer}.`, "red");
                } else if (currentQuestionType === "drag_drop") {
                     showMessage(`Sai rồi. Đáp án kéo thả chưa hoàn toàn chính xác. Vui lòng xem phản hồi màu sắc!`, "red");
                } else {
                     showMessage("Sai rồi. Vui lòng xem lại kết quả (Màu xanh lá là đúng, đỏ là sai)!", "red");
                }
            }
            correctnessStatus[questionIndex] = isCorrect;
            // Xử lý feedback cho Fill-in-the-Blank (cần gọi lại renderFillInTheBlankUI để update placeholder)
            if (currentQuestionType === "fill_in_the_blank") {
                renderFillInTheBlankUI(questions[questionIndex]);
            }
            updateSidebarHighlight(); // Cập nhật màu sắc trên sidebar
            return isCorrect;
        }
        function updateButtonStates() {
            const currentQuestion = questions[currentQuestionIndex];
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            nextButton.disabled = !isChecked;
            nextButton.classList.toggle('bg-gray-200', !isChecked);
            nextButton.classList.toggle('text-gray-800', !isChecked);
            nextButton.classList.toggle('enabled-next', isChecked);
            if (currentQuestion.type === "multi_select" || currentQuestion.type === "drag_drop") {
                checkAnswerButton.classList.toggle('hidden', isChecked);
                if (!isChecked) {
                    let isAnswered = false;
                    if (currentQuestion.type === "drag_drop") {
                        const droppedAnswers = answeredQuestions[currentQuestionIndex];
                        isAnswered = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                    } else if (currentQuestion.type === "multi_select") {
                        const currentSelections = optionsContainer.querySelectorAll('.selected-option').length;
                        isAnswered = currentSelections > 0;
                    }
                    checkAnswerButton.disabled = !isAnswered;
                    checkAnswerButton.classList.toggle('check-button-enabled', isAnswered);
                    checkAnswerButton.classList.toggle('check-button-disabled', !isAnswered);
                }
            }// 3. Logic cho nút CHECK FILL-IN-THE-BLANK
            if (currentQuestion.type === "fill_in_the_blank") {
                if (!isChecked) {
                    const isAnswered = fillInTheBlankInput.value.trim() !== "";
                    checkFillInTheBlankButton.disabled = !isAnswered;
                    checkFillInTheBlankButton.classList.toggle('check-button-enabled', isAnswered);
                    checkFillInTheBlankButton.classList.toggle('check-button-disabled', !isAnswered);
                    fillInTheBlankInput.oninput = updateButtonStates; 
                }
            }
        }
        nextButton.addEventListener('click', nextQuestion);
        function nextQuestion() {
            if (correctnessStatus[currentQuestionIndex] === null) {
                const currentType = questions[currentQuestionIndex].type;
                if (currentType === "multi_select" || currentType === "drag_drop" || currentType === "fill_in_the-blank") {
                    showMessage("Vui lòng nhấn nút 'Kiểm tra đáp án' trước khi chuyển câu.", "yellow");
                    return;
                }
            }// Chuyển sang câu tiếp theo (hoặc hoàn thành bài thi)
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }
        function jumpToQuestion(index) {
            currentQuestionIndex = index;
            showQuestion();
        }
        function goToStartScreen() {
            clearInterval(timerInterval);
            elapsedTime = 0; 
            timerDisplay.textContent = "00:00"; // Đặt lại đồng hồ hiển thị
            quizContent.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            sidebar.classList.add('hidden');
            startScreen.classList.remove('hidden');
        }
        function showResults() {
            clearInterval(timerInterval);
            quizContent.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            
            const totalCorrect = correctnessStatus.filter(status => status === true).length;
            const totalQuestions = questions.length;
            // TỐI ƯU HÓA TÍNH ĐIỂM: Cập nhật thẻ hiển thị điểm số
            finalScore.textContent = `${totalCorrect} / ${totalQuestions}`;
            if (totalCorrect === totalQuestions) {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Xin chúc mừng! Bạn đạt kết quả tuyệt đối.`;
            } else {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Hãy xem lại các câu trả lời của mình trên giao diện nhé.`;
            }
            sidebar.classList.add('hidden');
        }
        function restartQuiz() {
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            resultsScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden'); 
            startTimer();
            createQuestionList(); 
            showQuestion();
        }
        function startTimer() {
            clearInterval(timerInterval); 
            timerInterval = setInterval(() => {
                elapsedTime++;
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        function createQuestionList() {
            questionListContainer.innerHTML = '';
            questions.forEach((q, index) => {
                const button = document.createElement('button');
                button.textContent = index + 1;
                button.classList.add(
                    "w-8", "h-8", "rounded-full", "font-medium", "text-sm",
                    "bg-gray-200", "text-gray-800", "hover:bg-blue-200",
                    "transition-colors", "duration-200"
                );
                button.setAttribute('data-index', index);
                button.addEventListener('click', () => {
                    jumpToQuestion(index);
                });
                questionListContainer.appendChild(button);
            });
        }
        function updateSidebarHighlight() {
            const allQuestionButtons = questionListContainer.querySelectorAll('button');
            allQuestionButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'bg-green-500', 'bg-red-500', 'bg-yellow-400');
                const index = parseInt(btn.getAttribute('data-index'));
                if (index === currentQuestionIndex) {
                    btn.classList.add('bg-blue-600', 'text-white');
                } else if (correctnessStatus[index] === true) {
                    btn.classList.add('bg-green-500', 'text-white');
                } else if (correctnessStatus[index] === false) {
                    btn.classList.add('bg-red-500', 'text-white');
                } else if (answeredQuestions[index] !== null) {
                    btn.classList.add('bg-yellow-400', 'text-white');
                }
            });
        }
        function showMessage(text, color) {
            const existingMessage = quizContent.querySelector('.temp-message');
            if (existingMessage) existingMessage.remove();
            const colorClasses = {
                "yellow": "bg-yellow-100 border-yellow-400 text-yellow-700",
                "red": "bg-red-100 border-red-400 text-red-700",
                "green": "bg-green-100 border-green-400 text-green-700"
            };
            const messageBox = document.createElement('div');
            messageBox.textContent = text;
            const colorClassString = colorClasses[color] || colorClasses['yellow'];
            messageBox.classList.add(
                ...colorClassString.split(' '), 
                "border", "px-4", "py-3", "rounded", "relative", "mb-4", "temp-message"
            );
            quizContent.insertBefore(messageBox, questionCounter.nextElementSibling);
            setTimeout(() => messageBox.remove(), 3000); 
        }// --- Hàm XÁO TRỘN MẢNG (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            let shuffled = array.slice(); // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }// --- Khởi tạo sự kiện ---
        startButton.addEventListener('click', () => {
            // Đảm bảo reset trạng thái trước khi bắt đầu
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            // questions = shuffleArray(questions); // Xáo trộn câu hỏi
            startScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden');
            createQuestionList();
            startTimer();
            showQuestion();
        });
        restartButton.addEventListener('click', restartQuiz);
        exitButton.addEventListener('click', () => {
            showMessage("Đã thoát khỏi bài kiểm tra. Dữ liệu làm bài hiện tại sẽ không được lưu. Đang quay về màn hình bắt đầu...", "red");
            setTimeout(goToStartScreen, 1000);
        });
    </script>
</body>
</html>