<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bài 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="css/test.css">
</head>
<body class="flex flex-col items-center justify-between min-h-screen bg-gray-100">
    <header >
        <h1 class="textheader">An Khùng</h1>
        <button id="exit-button" class="btnExit">Thoát</button>
        <a href="index.html" class="btnHome">
            <i class="fa-solid fa-arrow-left" style="color: rgb(0, 0, 0); font-size: 20px; font-weight: bold; margin-left: 8px;"></i>Trang Chủ.
        </a>
    </header>
    <!-- Container chính (Chia làm 2 cột trên màn hình lớn) -->
    <div class="container mx-auto px-4 my-8 grid grid-cols-1 md:grid-cols-10 gap-8 items-start">
        <!-- KHUNG BÊN TRÁI: NỘI DUNG CÂU HỎI (7/10 cột) -->
        <div id="quiz-container" class="bg-white p-8 rounded-2xl shadow-xl w-full md:col-span-7">
            <!-- Màn hình bắt đầu bài kiểm tra -->
            <div id="start-screen" class="text-center">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">Bài 2</h1>
                <p class="text-gray-600 mb-6">Chào mừng bạn đến với bài kiểm tra! Hãy nhấn "Bắt đầu" để bắt đầu.</p>
                <button id="start-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Bắt đầu</button>
            </div>
            <!-- Nội dung Quiz: Hiển thị câu hỏi và đáp án -->
            <div id="quiz-content" class="hidden">
                <!-- Bộ đếm câu hỏi (VD: 1/10) -->
                <p id="question-counter" class="text-lg font-semibold text-gray-700 mb-2"></p>
                <!-- Tiêu đề/Nội dung câu hỏi -->
                <h2 id="question-text" class="text-xl text-gray-1500 mb-2"></h2><br>
                <!-- Hình minh họa câu hỏi (nếu có) -->
                <div id="question-image-container" class="mb-4 hidden">
                    <img id="question-image" src="" alt="Minh họa câu hỏi" class="mx-auto rounded-xl shadow-lg max-h-64 object-contain">
                </div>
                <!-- Thông báo cho câu hỏi Multi-Select -->
                <p id="multiselect-info" class="text-sm text-red-500 font-medium mb-4 hidden"><i>2 đáp án đúng!</i></p>
                <!-- 1. Container cho Single/Multi-Select (Chọn đáp án) -->
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- Các nút đáp án được tạo bằng JavaScript -->
                </div>
                <!-- 2. Container cho Drag & Drop (Kéo thả) -->
                <div id="dragdrop-container" class="hidden">
                    <p class="text-sm text-blue-500 font-medium mb-4">Kéo thả theo ý đúng</p>
                    <!-- Vùng kéo (Source): Chứa các thẻ chưa được thả -->
                    <div id="draggable-items-source" class="source-drop-zone drop-zone flex flex-wrap gap-3 p-4 bg-gray-50 border rounded-xl mb-6 shadow-inner">
                        <p class="text-gray-500 text-sm italic w-full source-placeholder">Kéo các thẻ ở đây... </p>
                    </div>
                    <!-- Vùng thả (Targets): Chứa các Category -->
                    <div id="drop-targets-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    </div>
                </div>
                <!-- 3. Container cho Fill-in-the-Blank (Điền từ) -->
                <div id="fill-in-the-blank-container" class="space-y-4 hidden mt-6">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <input 
                            type="text" 
                            id="fill-in-the-blank-input" 
                            placeholder="Nhập đáp án của bạn..." 
                            class="flex-grow p-3 border border-gray-300 rounded-lg transition duration-150"
                        >
                        <button 
                            id="check-fill-in-the-blank-button"
                            class="check-button-enabled text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:bg-gray-400"
                            onclick="checkFillInTheBlank()"
                        >
                            Kiểm tra đáp án
                        </button>
                    </div>
                </div>
                <!-- Thanh điều hướng dưới cùng -->
                <div class="flex justify-end items-center mt-6 border-t pt-4 space-x-4">
                    <button 
                        id="check-answer-button" 
                        class="hidden text-black font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105"
                    >
                        Kiểm tra
                    </button>
                    <button 
                        id="next-button" 
                        class="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-full shadow-md transition-all duration-300 transform hover:scale-105"
                    >
                        Tiếp
                    </button>
                </div>
            </div>
            <!-- Màn hình kết quả cuối bài thi -->
            <div id="results-screen" class="hidden text-center">
                <h2 class="text-3xl font-bold text-green-600 mb-4">Hoàn thành bài kiểm tra!</h2>
                <!-- HIỂN THỊ ĐIỂM SỐ ĐÃ TỐI ƯU HÓA -->
                <div class="bg-blue-50 p-6 rounded-2xl shadow-xl inline-block mb-6">
                    <p class="text-xl font-semibold text-gray-700">Điểm số của bạn:</p>
                    <!-- Thẻ hiển thị điểm số cuối cùng -->
                    <p id="final-score" class="text-6xl font-extrabold text-blue-700 mt-2">0 / 0</p>
                </div>
                <p id="result-message" class="text-gray-700 mb-6">Bạn có thể xem lại các câu trả lời của mình trên giao diện.</p>
                <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">Làm lại</button>
            </div>
        </div>
        <!-- KHUNG BÊN PHẢI: SIDEBAR (3/10 cột) -->
        <div id="sidebar" class="bg-white p-6 rounded-2xl shadow-xl w-full hidden md:block md:col-span-3 sticky top-8">
            <div class="mb-6 text-center">
                <p class="text-xl font-semibold text-gray-700 mb-2">Thời gian làm bài:</p>
                <!-- Đồng hồ đếm ngược/đếm thời gian -->
                <div id="timer" class="text-4xl font-bold text-red-500">00:00</div>
            </div>
            <div>
                <p class="text-lg font-semibold text-gray-700 mb-4">Danh sách câu hỏi:</p>
                <!-- Danh sách các nút câu hỏi để nhảy qua lại -->
                <div id="question-list-container" class="grid grid-cols-4 gap-2">
                    <!-- Các nút câu hỏi được tạo bằng JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="w-full bg-gray-800 text-white text-center py-4 px-6 mt-auto">
        <p class="text-sm">&copy; Website luyện tập!!!</p>
    </footer>
    <script>
        let questions = [
            // ===== CÂU 1 =====
            {
                question: "Mục tiêu của DevOps là gì trong thay đổi tư duy tổ chức?",
                options: [
                    "A. Tăng số lượng nhân viên vận hành",
                    "B. Tạo ra sự linh hoạt và phản hồi nhanh",
                    "C. Thúc đẩy quy trình làm việc theo silo",
                    "D. Tích hợp kiểm thử và triển khai vào quy trình phát triển"
                ],
                answer: ["B. Tạo ra sự linh hoạt và phản hồi nhanh", "D. Tích hợp kiểm thử và triển khai vào quy trình phát triển"],
                type: "multi_select"
            },

            // ===== CÂU 2 =====
            {
                question: "DevOps giúp xóa bỏ các rào cản nào trong tổ chức?<br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Bức tường ngăn giữa Dev và Ops",
                    "B. Thiếu hiểu biết giữa các nhóm dev, ops, customer",
                    "C. Quản trị thay đổi có kiểm soát",
                    "D. Giao tiếp rời rạc"
                ],
                answer: ["A. Bức tường ngăn giữa Dev và Ops", "B. Thiếu hiểu biết giữa các nhóm dev, ops, customer", "D. Giao tiếp rời rạc"],
                type: "multi_select"
            },
            // ===== CÂU 3 =====
            {
                question: "Đâu KHÔNG phải là các nguyên lý cốt lõi trong DevOps?<br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Tự động hóa kiểm thử",
                    "B. Viết tài liệu chi tiết bằng tay",
                    "C. Cập nhật tài liệu hàng năm",
                    "D. Mọi thứ do người quản lý quyết định"
                ],
                answer: ["B. Viết tài liệu chi tiết bằng tay", "C. Cập nhật tài liệu hàng năm", "D. Mọi thứ do người quản lý quyết định"],
                type: "multi_select"
            },

            // ===== CÂU 4 =====
            {
                question: "Để đảm bảo bảo mật thông tin trong DevOps, nên áp dụng:<br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Quét lỗ hổng tự động trong CI pipeline",
                    "B. Phân quyền truy cập theo vai trò",
                    "C. Lưu tất cả mật khẩu trong code",
                    "D. Sử dụng công cụ quản lý secrets"
                ],
                answer: ["A. Quét lỗ hổng tự động trong CI pipeline", "B. Phân quyền truy cập theo vai trò", "D. Sử dụng công cụ quản lý secrets"],
                type: "multi_select"
            },

            // ===== CÂU 5 =====
            {
                question: "Các công cụ CI/CD giúp thực hiện những nguyên lý nào sau đây?<br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Tích hợp liên tục",
                    "B. Phát hành liên tục",
                    "C. Sinh site cho mã",
                    "D. Triển khai liên tục"
                ],
                answer: ["A. Tích hợp liên tục", "B. Phát hành liên tục", "D. Triển khai liên tục"],
                type: "multi_select"
            },
            // ===== CÂU 6 =====
            {
                question: "Đâu là các nguyên lý cốt lõi của DevOps <br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Tự động hóa mọi thứ",
                    "B. Tập trung vào release theo tháng",
                    "C. Triển khai liên tục, hiệu quả, an toàn với sự phối hợp chặt chẽ của các bên liên quan",
                    "D. Tích hợp liên tục và giao tiếp thường xuyên"
                ],
                answer: ["A. Tự động hóa mọi thứ", "C. Triển khai liên tục, hiệu quả, an toàn với sự phối hợp chặt chẽ của các bên liên quan", "D. Tích hợp liên tục và giao tiếp thường xuyên"],
                type: "multi_select"
            },
            // ===== CÂU 7 =====
            {
                question: "Yếu tố văn hóa nào sau đây phù hợp với DevOps?",
                options: [
                    "A. Trách nhiệm thuộc riêng nhóm vận hành (Ops)",
                    "B. Giao tiếp cởi mở và minh bạch giữa các nhóm",
                    "C. Chia sẻ trách nhiệm giữa các nhóm Dev và Ops",
                    "D. Cấu trúc phân tầng nghiêm ngặt"
                ],
                answer: ["B. Giao tiếp cởi mở và minh bạch giữa các nhóm", "C. Chia sẻ trách nhiệm giữa các nhóm Dev và Ops"],
                type: "multi_select"
            },

            // ===== CÂU 8 =====
            {
                question: "DevOps khuyến khích tổ chức xây dựng văn hóa như thế nào?",
                options: [
                    "A. Văn hóa phản hồi nhanh, cải tiến liên tục",
                    "B. Văn hóa sợ sai, tránh lỗi",
                    "C. Văn hóa học hỏi từ sai lầm",
                    "D. Văn hóa trì hoãn lỗi và định kỳ khắc phục hàng tháng"
                ],
                answer: ["A. Văn hóa phản hồi nhanh, cải tiến liên tục", "C. Văn hóa học hỏi từ sai lầm"],
                type: "multi_select"
            },

            // ===== CÂU 9 =====
            {
                question: "Trong một hệ thống DevOps hiện đại, các mức kiểm thử liên tục nên áp dụng bao gồm:<br><br><strong>(chọn 3 đáp án đúng)</strong>",
                options: [
                    "A. Kiểm thử thủ công cuối kỳ",
                    "B. Kiểm thử hồi quy tự động",
                    "C. Kiểm thử đơn vị (Unit test)",
                    "D. Kiểm thử tích hợp"
                ],
                answer: ["B. Kiểm thử hồi quy tự động", "C. Kiểm thử đơn vị (Unit test)", "D. Kiểm thử tích hợp"],
                type: "multi_select"
            },

            // ===== CÂU 10 =====
            {
                question: "DevOps thay đổi tư duy làm việc bằng cách nào?",
                options: [
                    "A. Tăng tính cộng tác giữa đội ngũ phát triển và đội ngũ vận hành",
                    "B. Loại bỏ hoàn toàn kiểm thử",
                    "C. Khuyến khích cải tiến liên tục",
                    "D. Tách biệt vai trò phát triển và vận hành"
                ],
                answer: ["A. Tăng tính cộng tác giữa đội ngũ phát triển và đội ngũ vận hành", "C. Khuyến khích cải tiến liên tục"],
                type: "multi_select"
            },

            // ===== CÂU 11 =====
            {
                question: "Những nguyên lý DevOps nào giúp triển khai hạ tầng một cách có thể lặp lại, dễ kiểm soát, có thể rollback?",
                options: [
                    "A. Infrastructure as Code (IaC)",
                    "B. Continuous Deployment",
                    "C. Manual Configuration",
                    "D. IaaS (Infrastructure as a Service)"
                ],
                answer: ["A. Infrastructure as Code (IaC)", "B. Continuous Deployment"],
                type: "multi_select"
            },

            // ===== CÂU 12 =====
            {
                question: "Để đảm bảo hệ thống ổn định, DevOps cần thực hiện các nguyên lý nào?",
                options: [
                    "A. Triển khai thủ công theo ca trực",
                    "B. Giám sát & đo lường",
                    "C. Kiểm thử liên tục",
                    "D. Lập trình hướng sự kiện"
                ],
                answer: ["B. Giám sát & đo lường", "C. Kiểm thử liên tục"],
                type: "multi_select"
            },
            // ===== CÂU 13.1 =====

        {
            question: "DevOps yêu cầu sự minh bạch và phản hồi liên tục giữa các nhóm.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 13.2 =====

        {
            question: "Các tổ chức áp dụng DevOps có thể giữ nguyên mô hình tổ chức cũ mà không cần thay đổi tư duy các cấp lãnh đạo.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
            // ===== CÂU 13.3 =====

        {
            question: "Việc chia sẻ thông tin, dữ liệu là yếu tố văn hóa quan trọng trong môi trường DevOps.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 13.4 =====

        {
            question: "DevOps giúp giảm xung đột giữa nhóm phát triển và nhóm vận hành nhờ cùng chia sẻ mục tiêu.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 14.1 =====

        {
            question: "Nếu không có sự hỗ trợ từ lãnh đạo cấp cao, DevOps vẫn có thể triển khai hiệu quả trên toàn tổ chức.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
            // ===== CÂU 14.2 =====

        {
            question: "Chuyển từ Agile sang DevOps yêu cầu thay đổi lớn về tư duy, đặc biệt ở vai trò quản lý.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 14.3 =====

        {
            question: "Agile không đề cập đến vận hành, vì vậy khi doanh nghiệp chuyển sang DevOps, việc tích hợp vận hành trong DevOps là một thay đổi văn hóa lớn.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 14.4 =====

        {
            question: "Scrum thường chỉ tập trung vào phát triển, còn DevOps bao gồm cả vận hành và giám sát.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 15.1 =====

        {
            question: "Tự động hóa trong DevOps chỉ áp dụng cho quá trình build và deploy ứng dụng.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
            // ===== CÂU 15.2 =====

        {
            question: "Tự động hóa trong DevOps bao gồm build, test, deploy, monitoring, infrastructure provisioning và security.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 15.3 =====

        {
            question: "Tự động hóa trong DevOps giúp rút ngắn chu kỳ phát hành phần mềm, tăng tần suất release, giảm thiểu thao tác thủ công và lỗi con người.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "A. Đúng",
            type: "single_select"
        },
            // ===== CÂU 15.4 =====

        {
            question: "Tự động hóa trong DevOps làm giảm nhu cầu giám sát hệ thống vì mọi thứ đều diễn ra tự động.",
            options: [
                "A. Đúng",
                "B. Sai"
            ],
            answer: "B. Sai",
            type: "single_select"
        },
        {
            question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau: <br> Một hệ thống DevOps tốt sẽ tự động hóa được cả việc tạo môi trường hạ tầng mới thông qua ____(1)____. Công cụ để viết code IaC là ____(2)____. Cơ sở hạ tầng dự án cũng có thể được quản lý dưới dạng mã, công cụ thường được sử dụng để quản lý hạ tầng là _____(3)____.<br><br>Biết các thông tin có thể điền gồm: cơ sở hạ tầng dưới dạng code (iac), terraform, ansible",
            answer: "cơ sở hạ tầng dưới dạng code (iac), terraform, ansible",
            type: "fill_in_the_blank"
        },
        {
            question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau:<br>Kiến trúc _____(1)_____ cho phép chia nhỏ hệ thống thành các dịch vụ độc lập, dễ phát triển và triển khai riêng biệt. Công cụ _____(2)_____ thường được dùng để triển khai và điều phối các container microservices trong môi trường DevOps. Trong kiến trúc microservices, mỗi dịch vụ nên có cơ sở dữ liệu ______(3)______ để đảm bảo độc lập.<br><br>Biết các thông tin có thể điền bao gồm: microservices, riêng biệt (own database), k8s",
            answer: "microservices, k8s, riêng biệt (own database)",
            type: "fill_in_the_blank"
        },
        {
            question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau:<br>Trong DevOps, tích hợp liên tục được viết tắt là _____(1)______; phát hành liên tục viết tắt là ____(2)___ . Công cụ phổ biến để tự động hóa pipeline CI/CD là ___(3)_____, hoặc tính năng ____(4)____ của GitHub.<br><br>Biết các thông tin có thể điền bao gồm: cd, ci, jenkins, github actions",
            answer: "ci, cd, jenkins, github actions",
            type: "fill_in_the_blank"
        },
        {
            question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau? <br>Microservices cho phép các nhóm phát triển triển khai độc lập, từ đó thúc đẩy tinh thần ____(1)______ và phản hồi nhanh. Việc phát hành tự động từng dịch vụ riêng biệt được thực hiện nhờ _____(2)_____. Tích hợp microservices, tư duy DevOps và tự động hóa hoàn toàn giúp tổ chức đạt được sự ____(3)______ về kỹ thuật và vận hành.<br><br>Biết các thông tin có thể điền bao gồm: tự chủ, linh hoạt, cd pipelines",
            answer: "tự chủ, cd pipelines, linh hoạt",
            type: "fill_in_the_blank"
        },
        {
            question: "Điền thông tin thích hợp vào các chỗ trống trong phát biểu sau:<br>CI pipeline thường bao gồm các bước: kiểm tra cú pháp, biên dịch mã và chạy ____(1)____ tự động. Trong khi CI kết thúc ở bước kiểm thử, thì CD pipeline tiếp tục bằng việc ____(2)____ lên môi trường staging hoặc production. DevOps pipeline bao phủ cả quy trình từ lên kế hoạch, viết mã, kiểm thử, triển khai đến ____(3)____ và phản hồi.<br><br>Kèm theo thông tin gợi ý: Biết các thông tin có thể điền bao gồm: triển khai, kiểm thử, giám sát",
            answer: "kiểm thử, triển khai, giám sát",
            type: "fill_in_the_blank"
        },
        {
            question: "Kéo nguyên lý DevOps phù hợp với mô tả tương ứng?",
            type: "drag_drop",
            categories: ["Continuous Integration", "Monitoring","Infrastructure as Code"],
            items: [
                { id: "item1", text: "A. Tự động build khi có commit mới", correctCategory: "Continuous Integration" },
                { id: "item2", text: "B. Theo dõi CPU, memory hệ thống", correctCategory: "Monitoring" },
                { id: "item3", text: "C. Tạo môi trường staging bằng mã", correctCategory: "Infrastructure as Code"},
            ]
        },
        {
            question: "Kéo nguyên lý DevOps phù hợp với mô tả tương ứng?",
            type: "drag_drop",
            categories: ["Continuous Integration", "Monitoring","Infrastructure as Code"],
            items: [
                { id: "item1", text: "A. Tự động build khi có commit mới", correctCategory: "Continuous Integration" },
                { id: "item2", text: "B. Theo dõi CPU, memory hệ thống", correctCategory: "Monitoring" },
                { id: "item3", text: "C. Tạo môi trường staging bằng mã", correctCategory: "Infrastructure as Code"},
            ]
        },
        {
            question: "Kéo thả giai đoạn DevOps tương ứng với công cụ hỗ trợ?",
            type: "drag_drop",
            categories: ["Tích hợp và phát hành liên tục", "Giám sát","Quản lý mã nguồn"],
            items: [
                { id: "item1", text: "Jenkins", correctCategory: "Tích hợp và phát hành liên tục" },
                { id: "item2", text: "Prometheus", correctCategory: "Giám sát" },
                { id: "item3", text: "Git", correctCategory: "Quản lý mã nguồn"},
            ]
        },
        {
            question: "Kéo đúng mục đích sử dụng với công cụ, kỹ thuật áp dụng trong kiến trúc microservices?",
            type: "drag_drop",
            categories: ["Docker", "Kubernetes","REST API"],
            items: [
                { id: "item1", text: "Container hóa dịch vụ", correctCategory: "Docker" },
                { id: "item2", text: "Điều phối container", correctCategory: "Kubernetes" },
                { id: "item3", text: "Giao tiếp giữa các microservices", correctCategory: "REST API"},
            ]
        },
        {
            question: "Kéo vai trò đúng trách nhiệm vào từng vai trò tương ứng trong nhóm DevOps?",
            type: "drag_drop",
            categories: ["Operations", "QA Engineer","Developer"],
            items: [
                { id: "item1", text: "Vận hành, triển khai hệ thống", correctCategory: "Operations" },
                { id: "item2", text: "Kiểm thử và đảm bảo chất lượng", correctCategory: "QA Engineer" },
                { id: "item3", text: "Viết mã, tích hợp tính năng mới", correctCategory: "Developer"},
            ]
        },
        {
            question: "Ghép trách nhiệm với vai trò trong nhóm DevOps?",
            type: "drag_drop",
            categories: ["Developer & tester", "Scrum Master", "Product Owner","Ops Engineer"],
            items: [
                { id: "item1", text: "Phát triển và kiểm thử tính năng sản phẩm", correctCategory: "Developer & tester" },
                { id: "item2", text: "Điều phối nhóm, loại bỏ trở ngại", correctCategory: "Scrum Master" },
                { id: "item3", text: "Quản lý yêu cầu, ưu tiên backlog", correctCategory:"Product Owner"},
                { id: "item4", text: "Thiết lập CI/CD, tự động hóa hạ tầng", correctCategory: "Ops Engineer" }
            ]
        },
        {
            question: "Kéo đúng nguyên lý DevOps vào  chức năng hệ thống bán hàng",
            type: "drag_drop",
            categories: ["Continuous Deployment", "Microservices + IaC", "Monitoring & Logging"],
            items: [
                { id: "item1", text: "Triển khai nhanh module thanh toán", correctCategory: "Continuous Deployment" },
                { id: "item2", text: "Tách sản phẩm thành dịch vụ riêng, tự động cấp phát hạ tầng", correctCategory: "Microservices + IaC" },
                { id: "item3", text: "Theo dõi tồn kho theo thời gian thực", correctCategory:"Monitoring & Logging"},
            ]
        },
        {
            question: "Kéo thông tin phù hợp với đặc điểm của microservice với cột bên phải",
            type: "drag_drop",
            categories: ["Tách biệt chức năng", "Sử dụng cơ sở dữ liệu riêng", "Triển khai độc lập"],
            items: [
                { id: "item1", text: "Microservice đảm nhiệm một nghiệp vụ cụ thể", correctCategory: "Tách biệt chức năng" },
                { id: "item2", text: "Giúp không bị phụ thuộc và đảm bảo toàn vẹn dữ liệu", correctCategory: "Sử dụng cơ sở dữ liệu riêng" },
                { id: "item3", text: "Có thể update hay deploy từng phần mà không ảnh hưởng hệ thống chung", correctCategory:"Triển khai độc lập"},
            ]
        },
        {
            question: "Kéo lợi ích thả vào nguyên lý DevOps tương ứng?",
            type: "drag_drop",
            categories: ["Continuous Integration", "IaC", "Giám sát & Logs"],
            items: [
                { id: "item1", text: "Phát hiện lỗi sớm trong mã nguồn", correctCategory: "Continuous Integration" },
                { id: "item2", text: "Dễ dàng cấu hình, mở rộng hạ tầng", correctCategory: "IaC" },
                { id: "item3", text: "Phân tích sự cố, đảm bảo ổn định", correctCategory: "Giám sát & Logs"},
            ]
        },
        ];
        let currentQuestionIndex = 0; // Chỉ số câu hỏi hiện tại
        let elapsedTime = 0; // Thời gian làm bài (giây)
        let timerInterval; // Biến lưu trữ Interval của đồng hồ
        let answeredQuestions = new Array(questions.length).fill(null);
        let correctnessStatus = new Array(questions.length).fill(null);
        // Lấy các phần tử DOM cần thiết
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const quizContent = document.getElementById('quiz-content');
        const questionCounter = document.getElementById('question-counter');
        const multiselectInfo = document.getElementById('multiselect-info');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const dragdropContainer = document.getElementById('dragdrop-container');
        const draggableItemsSource = document.getElementById('draggable-items-source');
        const dropTargetsContainer = document.getElementById('drop-targets-container');
        const fillInTheBlankContainer = document.getElementById('fill-in-the-blank-container');
        const fillInTheBlankInput = document.getElementById('fill-in-the-blank-input');
        const checkFillInTheBlankButton = document.getElementById('check-fill-in-the-blank-button');
        const checkAnswerButton = document.getElementById('check-answer-button'); // Nút kiểm tra chung (Multi-select, Drag & Drop)
        const nextButton = document.getElementById('next-button');
        const resultsScreen = document.getElementById('results-screen');
        const restartButton = document.getElementById('restart-button');
        // SỬA LỖI VÀ TÍNH ĐIỂM: Thêm các dòng này để khai báo biến DOM
        const resultMessage = document.getElementById('result-message'); 
        const exitButton = document.getElementById('exit-button'); 
        const finalScore = document.getElementById('final-score'); // Thẻ hiển thị điểm số
        
        const sidebar = document.getElementById('sidebar');
        const timerDisplay = document.getElementById('timer');
        const questionListContainer = document.getElementById('question-list-container');
        function normalizeString(str) {
            let normalized = str.toLowerCase().trim();
            normalized = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
            return normalized.replace(/\s+/g, '');
        }
        fillInTheBlankInput.onkeypress = (event) => {
            if (event.key === 'Enter') checkFillInTheBlank();
        };
        function drag(event) {
            event.dataTransfer.setData("text/plain", event.target.id);
            event.target.classList.add('opacity-50');
        }
        function dragEnd(event) {
            event.target.classList.remove('opacity-50');
        }
        function allowDrop(event) {
            event.preventDefault(); // Cho phép thả
            const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        function dragLeave(event) {
             const target = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        function drop(event, categoryName) {
            event.preventDefault();
            let targetZone = event.target.closest('.drop-zone') || event.target.closest('.source-drop-zone');
            // Nếu đã kiểm tra (có feedback), không cho phép tương tác
            if (!targetZone || correctnessStatus[currentQuestionIndex] !== null) return; 
            targetZone.classList.remove('drag-over');
            const itemId = event.dataTransfer.getData("text/plain");
            const draggedElement = document.getElementById(itemId);
            if (draggedElement) {
                const oldParent = draggedElement.parentElement;
                if (oldParent) {
                    oldParent.removeChild(draggedElement);
                }
                targetZone.appendChild(draggedElement);
                let currentAnswer = answeredQuestions[currentQuestionIndex] || {};
                const itemText = draggedElement.textContent.trim(); 

                const isDroppedBackToSource = targetZone.id === 'draggable-items-source';

                if (isDroppedBackToSource) {
                    delete currentAnswer[itemText]; 
                } else { 
                    currentAnswer[itemText] = categoryName;
                }
                answeredQuestions[currentQuestionIndex] = Object.keys(currentAnswer).length > 0 ? currentAnswer : null;
                updateButtonStates();
            }
        }
        function checkCorrectness(questionIndex, selectedAnswers) {
            const currentQuestion = questions[questionIndex];
            if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = selectedAnswers || answeredQuestions[questionIndex];
                if (!droppedAnswers) return false;
                if (Object.keys(droppedAnswers).length !== currentQuestion.items.length) {
                    return false;
                }
                return currentQuestion.items.every(item => {
                    const droppedCategory = droppedAnswers[item.text];
                    return droppedCategory === item.correctCategory;
                });
            } else if (currentQuestion.type === "fill_in_the_blank") {
                 const userAnswer = selectedAnswers || answeredQuestions[questionIndex];
                 if (!userAnswer) return false;
                 const normalizedUserAnswer = normalizeString(userAnswer);
                 const normalizedCorrectAnswer = normalizeString(currentQuestion.answer);

                 return normalizedUserAnswer === normalizedCorrectAnswer;
            } else {
                const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                if (!Array.isArray(selectedAnswers)) {
                    selectedAnswers = selectedAnswers !== null ? [selectedAnswers] : [];
                }
                if (selectedAnswers.length !== correctAnswers.length) {
                    return false;
                }
                selectedAnswers.sort();
                correctAnswers.sort();
                return JSON.stringify(selectedAnswers) === JSON.stringify(correctAnswers);
            }
        }
        function showQuestion() {
            const currentQuestion = questions[currentQuestionIndex];
            questionCounter.textContent = `Câu hỏi: ${currentQuestionIndex + 1} / ${questions.length}`;
            questionText.innerHTML = currentQuestion.question;
            // ======= HIỂN THỊ HÌNH ẢNH MINH HỌA NẾU CÓ =======
            const imageContainer = document.getElementById("question-image-container");
            const imageElement = document.getElementById("question-image");
            if (currentQuestion.image) {
                imageElement.src = currentQuestion.image;
                imageContainer.classList.remove("hidden");
            } else {
                imageContainer.classList.add("hidden");
            }
            optionsContainer.classList.add('hidden');
            multiselectInfo.classList.add('hidden');
            dragdropContainer.classList.add('hidden');
            fillInTheBlankContainer.classList.add('hidden'); 
            checkAnswerButton.classList.add('hidden'); 
            if (currentQuestion.type === "drag_drop") {
                renderDragDropUI(currentQuestion);
                dragdropContainer.classList.remove('hidden');
            } else if (currentQuestion.type === "fill_in_the_blank") {
                renderFillInTheBlankUI(currentQuestion);
                fillInTheBlankContainer.classList.remove('hidden');
            } else {
                renderSelectUI(currentQuestion);
                optionsContainer.classList.remove('hidden');
            }
            nextButton.textContent = currentQuestionIndex >= questions.length - 1 ? "Hoàn thành bài thi" : "Câu tiếp theo";
            updateButtonStates();
            updateSidebarHighlight();
        }
        function renderSelectUI(currentQuestion) {
            const isMulti = currentQuestion.type === "multi_select";
            multiselectInfo.classList.toggle('hidden', !isMulti);
            checkAnswerButton.classList.toggle('hidden', !isMulti); // Hiển thị nút kiểm tra chỉ cho Multi-Select
            optionsContainer.innerHTML = '';
            const savedAnswer = answeredQuestions[currentQuestionIndex];
            const savedAnswersArray = Array.isArray(savedAnswer) ? savedAnswer : (savedAnswer !== null ? [savedAnswer] : []);
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option;
                let classes = [
                    "answer-button", "w-full", "py-3", "px-4", "rounded-xl", "text-center", 
                    "bg-gray-100", "border-2", "border-gray-300", 
                    "transition-all", "duration-200",
                    "font-medium", "text-gray-800", "shadow-sm"
                ];
                button.classList.add(...classes);
                if (isChecked) {
                    button.disabled = true;
                    button.classList.add("cursor-not-allowed");
                    const correctAnswers = Array.isArray(currentQuestion.answer) ? currentQuestion.answer : [currentQuestion.answer];
                    const isCorrectOption = correctAnswers.includes(option);
                    const isUserSelected = savedAnswersArray.includes(option);
                    if (isCorrectOption) {
                        button.classList.add("bg-green-500", "text-white", "border-green-600");
                        button.classList.remove("bg-gray-100", "border-gray-300");
                    }
                    if (isUserSelected && !isCorrectOption) {
                        button.classList.add("bg-red-500", "text-white", "border-red-600");
                        button.classList.remove("bg-green-500", "border-green-600", "bg-gray-100", "border-gray-300");
                    }
                } else {
                    button.classList.add("hover:bg-blue-100", "hover:border-blue-500");
                    if (isMulti) {
                        button.addEventListener('click', (e) => {
                            toggleSelection(e.currentTarget);
                            updateButtonStates(); 
                        });
                    } else {
                        button.addEventListener('click', (e) => singleSelectCheck(option, e.currentTarget));
                    }
                    if (savedAnswersArray.includes(option)) {
                        button.classList.add('selected-option');
                    }
                }
                optionsContainer.appendChild(button);
            });
        }
        function renderFillInTheBlankUI(currentQuestion) {
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const savedAnswer = answeredQuestions[currentQuestionIndex] || "";
            fillInTheBlankInput.value = savedAnswer;
            fillInTheBlankInput.disabled = isChecked;
            fillInTheBlankInput.classList.remove('correct', 'incorrect');
            checkFillInTheBlankButton.classList.toggle('hidden', isChecked);
            if (isChecked) {
                const isCorrect = correctnessStatus[currentQuestionIndex];
                fillInTheBlankInput.classList.add(isCorrect ? 'correct' : 'incorrect');
                if (!isCorrect) {
                     fillInTheBlankInput.placeholder = `Đáp án đúng: ${currentQuestion.answer}`;
                }
            } else {
                fillInTheBlankInput.placeholder = "Nhập đáp án của bạn...";
            }
            updateButtonStates(); 
        }
        function checkFillInTheBlank() {
            const userAnswer = fillInTheBlankInput.value.trim();
            if (userAnswer === "") {
                showMessage("Vui lòng nhập đáp án vào ô trống.", "yellow");
                return;
            }// 1. Lưu đáp án
            answeredQuestions[currentQuestionIndex] = userAnswer;
            checkAndApplyFeedback(currentQuestionIndex); 
            fillInTheBlankInput.disabled = true;
            checkFillInTheBlankButton.classList.add('hidden');
            updateButtonStates(); 
        }// --- Render Logic cho Drag & Drop ---
        function renderDragDropUI(currentQuestion) {
            draggableItemsSource.innerHTML = '';
            dropTargetsContainer.innerHTML = '';
            const savedDrops = answeredQuestions[currentQuestionIndex] || {};
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            const itemsDataMap = new Map(currentQuestion.items.map(item => [item.text, item]));
            checkAnswerButton.classList.remove('hidden');
            const sourcePlaceholder = document.createElement('p');
            sourcePlaceholder.classList.add('text-gray-500', 'text-sm', 'italic', 'w-full', 'source-placeholder');
            draggableItemsSource.ondragover = allowDrop;
            draggableItemsSource.ondragleave = dragLeave;
            if (!isChecked) {
                draggableItemsSource.ondrop = (e) => drop(e, null); 
                sourcePlaceholder.textContent = 'Kéo các thẻ ở đây... (Kéo thẻ từ ô đáp án về đây để "kéo ra")'; 
                sourcePlaceholder.classList.toggle('hidden', currentQuestion.items.length !== Object.keys(savedDrops).length);
            } else {
                draggableItemsSource.ondrop = null; // Vô hiệu hóa kéo/thả
                sourcePlaceholder.textContent = 'Đã hoàn thành.';
                sourcePlaceholder.classList.add('hidden'); 
            }
            draggableItemsSource.appendChild(sourcePlaceholder);
            const dropZones = {};
            currentQuestion.categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.classList.add('bg-gray-50', 'p-4', 'rounded-xl', 'shadow-md', 'flex', 'flex-col');
                const title = document.createElement('h3');
                title.textContent = category;
                title.classList.add('text-lg', 'font-bold', 'text-blue-700', 'mb-3', 'border-b', 'pb-2');
                categoryDiv.appendChild(title);
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone', 'flex', 'flex-wrap', 'gap-2', 'p-3', 'rounded-lg', 'flex-grow');
                dropZone.setAttribute('data-category', category);
                if (!isChecked) {
                    dropZone.ondragover = allowDrop;
                    dropZone.ondragleave = dragLeave;
                    dropZone.ondrop = (e) => drop(e, category); 
                } else {
                    dropZone.ondrop = null; 
                    dropZone.style.cursor = 'default';
                    const correctItemsForCategory = currentQuestion.items.filter(item => item.correctCategory === category);
                    const droppedItems = Object.entries(savedDrops)
                        .filter(([itemText, cat]) => cat === category)
                        .map(([itemText]) => itemText);
                    const correctlyPlacedCount = droppedItems.filter(text => itemsDataMap.get(text).correctCategory === category).length;
                    const incorrectlyPlacedCount = droppedItems.length - correctlyPlacedCount;
                    const missingCorrectCount = correctItemsForCategory.length - correctlyPlacedCount;
                    if (incorrectlyPlacedCount > 0 || missingCorrectCount > 0) {
                        dropZone.classList.add('incorrect-drop-zone');
                    } else if (correctlyPlacedCount > 0 && incorrectlyPlacedCount === 0 && missingCorrectCount === 0) {
                        dropZone.classList.add('correct-drop-zone');
                    }
                }
                dropTargetsContainer.appendChild(categoryDiv).appendChild(dropZone);
                dropZones[category] = dropZone;
            });
            currentQuestion.items.forEach(item => {
                const itemEl = createDraggableItem(item, isChecked);
                const droppedCategory = savedDrops[item.text];
                if (droppedCategory) {
                    const targetZone = dropZones[droppedCategory];
                    if (targetZone) {
                        targetZone.appendChild(itemEl);
                    }
                    if (isChecked) {
                        const isCorrect = droppedCategory === item.correctCategory;
                        itemEl.classList.remove('bg-white', 'border-gray-300');
                        itemEl.classList.add('text-gray-900', 'shadow-md', 'ring-2');
                        if (isCorrect) {
                            itemEl.classList.add('bg-green-200', 'ring-green-500');
                        } else {
                            itemEl.classList.add('bg-red-200', 'ring-red-500');
                            const correctHint = document.createElement('span');
                            correctHint.textContent = `(Đúng: ${item.correctCategory})`;
                            correctHint.classList.add('text-xs', 'text-red-700', 'mt-1', 'block', 'font-normal');
                            itemEl.appendChild(correctHint);
                        }
                    }
                } else {// Item chưa được thả -> Đặt vào vùng Source
                    draggableItemsSource.appendChild(itemEl);
                }
            });// Ẩn placeholder Source nếu không còn item nào
            const placeholder = draggableItemsSource.querySelector('.source-placeholder');
            if (placeholder) placeholder.classList.toggle('hidden', currentQuestion.items.length === Object.keys(savedDrops).length);
        }// Hàm tạo element cho thẻ kéo
        function createDraggableItem(item, isChecked) {
            const itemEl = document.createElement('div');
            itemEl.id = item.id;
            itemEl.textContent = item.text;
            itemEl.classList.add(
                'draggable-item', 'p-3', 'rounded-lg', 'shadow-sm', 'font-medium', 'text-sm', 'text-gray-800'
            );
            if (!isChecked) {
                itemEl.setAttribute('draggable', 'true');
                itemEl.ondragstart = drag;
                itemEl.ondragend = dragEnd;
            } else {
                itemEl.setAttribute('draggable', 'false');
                itemEl.style.cursor = 'default';
            }
            return itemEl;
        }// --- Logic Xử lý Đáp án (Select) ---
        function toggleSelection(button) {
            button.classList.toggle('selected-option');
        }
        function singleSelectCheck(selectedOption, button) {
            answeredQuestions[currentQuestionIndex] = selectedOption;
            checkAndApplyFeedback(currentQuestionIndex);
            renderSelectUI(questions[currentQuestionIndex]);
            updateButtonStates();
        }// Xử lý nút CHECK ANSWER (cho Multi-Select và Drag & Drop)
        checkAnswerButton.addEventListener('click', () => {
            const currentQuestion = questions[currentQuestionIndex];
            if (currentQuestion.type === "multi_select") {
                const allOptionButtons = optionsContainer.querySelectorAll('button');
                const selectedOptions = Array.from(allOptionButtons)
                    .filter(btn => btn.classList.contains('selected-option'))
                    .map(btn => btn.textContent);
                if (selectedOptions.length === 0) {
                    showMessage("Vui lòng chọn ít nhất một đáp án trước khi kiểm tra.", "yellow");
                    return;
                }// Lưu đáp án và kiểm tra
                answeredQuestions[currentQuestionIndex] = selectedOptions;
                checkAndApplyFeedback(currentQuestionIndex);
                renderSelectUI(questions[currentQuestionIndex]);
            } else if (currentQuestion.type === "drag_drop") {
                const droppedAnswers = answeredQuestions[currentQuestionIndex];
                const isAllDropped = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                if (!isAllDropped) {
                    showMessage("Vui lòng kéo thả tất cả các thẻ vào vị trí trước khi kiểm tra.", "yellow");
                    return;
                }
                checkAndApplyFeedback(currentQuestionIndex);
                renderDragDropUI(questions[currentQuestionIndex]); // Render lại để hiển thị feedback
            }
            updateButtonStates();
        });
        // Hàm kiểm tra và áp dụng phản hồi
        function checkAndApplyFeedback(questionIndex) {
            const savedAnswer = answeredQuestions[questionIndex];
            const isCorrect = checkCorrectness(questionIndex, savedAnswer);
            const currentQuestionType = questions[questionIndex].type;
            if (isCorrect) {
                showMessage("🎉 Chúc mừng, đáp án chính xác!", "green");
            } else {
                if (currentQuestionType === "fill_in_the_blank") {
                     showMessage(`Sai rồi. Đáp án đúng là: ${questions[questionIndex].answer}.`, "red");
                } else if (currentQuestionType === "drag_drop") {
                     showMessage(`Sai rồi. Đáp án kéo thả chưa hoàn toàn chính xác. Vui lòng xem phản hồi màu sắc!`, "red");
                } else {
                     showMessage("Sai rồi. Vui lòng xem lại kết quả (Màu xanh lá là đúng, đỏ là sai)!", "red");
                }
            }
            correctnessStatus[questionIndex] = isCorrect;
            // Xử lý feedback cho Fill-in-the-Blank (cần gọi lại renderFillInTheBlankUI để update placeholder)
            if (currentQuestionType === "fill_in_the_blank") {
                renderFillInTheBlankUI(questions[questionIndex]);
            }
            updateSidebarHighlight(); // Cập nhật màu sắc trên sidebar
            return isCorrect;
        }
        function updateButtonStates() {
            const currentQuestion = questions[currentQuestionIndex];
            const isChecked = correctnessStatus[currentQuestionIndex] !== null;
            nextButton.disabled = !isChecked;
            nextButton.classList.toggle('bg-gray-200', !isChecked);
            nextButton.classList.toggle('text-gray-800', !isChecked);
            nextButton.classList.toggle('enabled-next', isChecked);
            if (currentQuestion.type === "multi_select" || currentQuestion.type === "drag_drop") {
                checkAnswerButton.classList.toggle('hidden', isChecked);
                if (!isChecked) {
                    let isAnswered = false;
                    if (currentQuestion.type === "drag_drop") {
                        const droppedAnswers = answeredQuestions[currentQuestionIndex];
                        isAnswered = droppedAnswers !== null && droppedAnswers && Object.keys(droppedAnswers).length === currentQuestion.items.length;
                    } else if (currentQuestion.type === "multi_select") {
                        const currentSelections = optionsContainer.querySelectorAll('.selected-option').length;
                        isAnswered = currentSelections > 0;
                    }
                    checkAnswerButton.disabled = !isAnswered;
                    checkAnswerButton.classList.toggle('check-button-enabled', isAnswered);
                    checkAnswerButton.classList.toggle('check-button-disabled', !isAnswered);
                }
            }// 3. Logic cho nút CHECK FILL-IN-THE-BLANK
            if (currentQuestion.type === "fill_in_the_blank") {
                if (!isChecked) {
                    const isAnswered = fillInTheBlankInput.value.trim() !== "";
                    checkFillInTheBlankButton.disabled = !isAnswered;
                    checkFillInTheBlankButton.classList.toggle('check-button-enabled', isAnswered);
                    checkFillInTheBlankButton.classList.toggle('check-button-disabled', !isAnswered);
                    fillInTheBlankInput.oninput = updateButtonStates; 
                }
            }
        }
        nextButton.addEventListener('click', nextQuestion);
        function nextQuestion() {
            if (correctnessStatus[currentQuestionIndex] === null) {
                const currentType = questions[currentQuestionIndex].type;
                if (currentType === "multi_select" || currentType === "drag_drop" || currentType === "fill_in_the-blank") {
                    showMessage("Vui lòng nhấn nút 'Kiểm tra đáp án' trước khi chuyển câu.", "yellow");
                    return;
                }
            }// Chuyển sang câu tiếp theo (hoặc hoàn thành bài thi)
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }
        function jumpToQuestion(index) {
            currentQuestionIndex = index;
            showQuestion();
        }
        function goToStartScreen() {
            clearInterval(timerInterval);
            elapsedTime = 0; 
            timerDisplay.textContent = "00:00"; // Đặt lại đồng hồ hiển thị
            quizContent.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            sidebar.classList.add('hidden');
            startScreen.classList.remove('hidden');
        }
        function showResults() {
            clearInterval(timerInterval);
            quizContent.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            
            const totalCorrect = correctnessStatus.filter(status => status === true).length;
            const totalQuestions = questions.length;
            // TỐI ƯU HÓA TÍNH ĐIỂM: Cập nhật thẻ hiển thị điểm số
            finalScore.textContent = `${totalCorrect} / ${totalQuestions}`;
            if (totalCorrect === totalQuestions) {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Xin chúc mừng! Bạn đạt kết quả tuyệt đối.`;
            } else {
                resultMessage.textContent = `Bạn đã trả lời đúng ${totalCorrect} / ${totalQuestions} câu. Hãy xem lại các câu trả lời của mình trên giao diện nhé.`;
            }
            sidebar.classList.add('hidden');
        }
        function restartQuiz() {
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            resultsScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden'); 
            startTimer();
            createQuestionList(); 
            showQuestion();
        }
        function startTimer() {
            clearInterval(timerInterval); 
            timerInterval = setInterval(() => {
                elapsedTime++;
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        function createQuestionList() {
            questionListContainer.innerHTML = '';
            questions.forEach((q, index) => {
                const button = document.createElement('button');
                button.textContent = index + 1;
                button.classList.add(
                    "w-8", "h-8", "rounded-full", "font-medium", "text-sm",
                    "bg-gray-200", "text-gray-800", "hover:bg-blue-200",
                    "transition-colors", "duration-200"
                );
                button.setAttribute('data-index', index);
                button.addEventListener('click', () => {
                    jumpToQuestion(index);
                });
                questionListContainer.appendChild(button);
            });
        }
        function updateSidebarHighlight() {
            const allQuestionButtons = questionListContainer.querySelectorAll('button');
            allQuestionButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'bg-green-500', 'bg-red-500', 'bg-yellow-400');
                const index = parseInt(btn.getAttribute('data-index'));
                if (index === currentQuestionIndex) {
                    btn.classList.add('bg-blue-600', 'text-white');
                } else if (correctnessStatus[index] === true) {
                    btn.classList.add('bg-green-500', 'text-white');
                } else if (correctnessStatus[index] === false) {
                    btn.classList.add('bg-red-500', 'text-white');
                } else if (answeredQuestions[index] !== null) {
                    btn.classList.add('bg-yellow-400', 'text-white');
                }
            });
        }
        function showMessage(text, color) {
            const existingMessage = quizContent.querySelector('.temp-message');
            if (existingMessage) existingMessage.remove();
            const colorClasses = {
                "yellow": "bg-yellow-100 border-yellow-400 text-yellow-700",
                "red": "bg-red-100 border-red-400 text-red-700",
                "green": "bg-green-100 border-green-400 text-green-700"
            };
            const messageBox = document.createElement('div');
            messageBox.textContent = text;
            const colorClassString = colorClasses[color] || colorClasses['yellow'];
            messageBox.classList.add(
                ...colorClassString.split(' '), 
                "border", "px-4", "py-3", "rounded", "relative", "mb-4", "temp-message"
            );
            quizContent.insertBefore(messageBox, questionCounter.nextElementSibling);
            setTimeout(() => messageBox.remove(), 3000); 
        }// --- Hàm XÁO TRỘN MẢNG (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            let shuffled = array.slice(); // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }// --- Khởi tạo sự kiện ---
        startButton.addEventListener('click', () => {
            // Đảm bảo reset trạng thái trước khi bắt đầu
            currentQuestionIndex = 0;
            answeredQuestions = new Array(questions.length).fill(null);
            correctnessStatus = new Array(questions.length).fill(null);
            // questions = shuffleArray(questions); // Xáo trộn câu hỏi
            startScreen.classList.add('hidden');
            quizContent.classList.remove('hidden');
            sidebar.classList.remove('hidden');
            createQuestionList();
            startTimer();
            showQuestion();
        });
        restartButton.addEventListener('click', restartQuiz);
        exitButton.addEventListener('click', () => {
            showMessage("Đã thoát khỏi bài kiểm tra. Dữ liệu làm bài hiện tại sẽ không được lưu. Đang quay về màn hình bắt đầu...", "red");
            setTimeout(goToStartScreen, 1000);
        });
    </script>
</body>
</html>